
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>1.6. Berechenbarkeit &#8212; Computational Thinking</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="2. Was ist Information?" href="../02-2/information.html" />
    <link rel="prev" title="1.5. Der Informationskreislauf" href="4-information-flow.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/logo-HM.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Computational Thinking</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Computational Thinking
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Einleitung
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../01-1/course.html">
   1. Kurskonzept
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-1/1-teaching.html">
     1.1. Lehrkonzept
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-1/2-learn-how-to-think.html">
     1.2. Denken lernen?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../01-2/what-is-ct.html">
   2. Was ist Computational Thinking?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-2/1-informatics-and-ct.html">
     2.1. Informatik und CT
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-2/2-repetition-is-the-key.html">
     2.2. Wiederholung als Grundlage
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../01-3/history.html">
   3. Geschichte der Computer und Algorithmen
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-3/1-ancient.html">
     3.1. Antike
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-3/2-middleages.html">
     3.2. Mittelalter bis 19. Jahrundert
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-3/3-today.html">
     3.3. 19. Jahrundert bis heute
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-3/4-future.html">
     3.4. Ausblick
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../01-4/why-ct.html">
   4. Warum Computational Thinking?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-4/1-intrinsic-value.html">
     4.1. Intrinsischer Wert
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-4/2-usefulness.html">
     4.2. Langfristiger Nutzen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-4/3-self-determination.html">
     4.3. Selbstbestimmt durch CT
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../01-5/sorting.html">
   5. Lasst uns Denken
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-5/1-sort-cards.html">
     5.1. Karten sortieren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-5/2-sort-cards-with-python.html">
     5.2. Karten sortieren in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-5/3-sort-numbers.html">
     5.3. Zahlen sortieren in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01-5/4-sort-anything.html">
     5.4. Allgemeines Sortieren in Python
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Theorie
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="information-processing.html">
   1. Der digitale Computer
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="1-basics.html">
     1.1. Grundlagen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="2-interpretation.html">
     1.2. Interpretation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="2-representation.html">
     1.3. Repr√§sentationen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="3-manipulation.html">
     1.4. Manipulation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="4-information-flow.html">
     1.5. Der Informationskreislauf
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     1.6. Berechenbarkeit
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../02-2/information.html">
   2. Was ist Information?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-2/1-natural-science.html">
     2.1. Naturwissenschaften
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-2/2-formal-science.html">
     2.2. Strukturwissenschaften
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-2/3-critic.html">
     2.3. Kritik
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-2/4-humanics.html">
     2.4. Geisteswissenschaften
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-2/5-summary.html">
     2.5. Zusammenfassung
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../02-3/languages.html">
   3. Programmiersprachen
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-3/1-abstraction.html">
     3.1. Abstraktion des Computers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-3/2-success-criteria.html">
     3.2. Erfolgsfaktoren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-3/3-imperative-vs-functional.html">
     3.3. Imperativ vs. funktional
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-3/4-language-evolution.html">
     3.4. Sprachevolution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-3/5-python.html">
     3.5. Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-3/6-diversity.html">
     3.6. Diversit√§t
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../02-4/the-art-of-programming.html">
   4. Die Kunst des Programmierens
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-4/1-algorithms.html">
     4.1. Algorithmen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-4/2-programming.html">
     4.2. Programmieren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-4/3-code.html">
     4.3. Programmiercode
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02-4/4-repetition-and-recursion.html">
     4.4. Wiederholung
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Python
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../03-1/introduction.html">
   1. Programmieren in Python
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-2/python-environment.html">
   2. Das Python √ñkosystem
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-2/1-installation.html">
     2.1. Installation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-2/2-run.html">
     2.2. Python ausf√ºhren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-2/3-notebooks.html">
     2.3. Jupyter Notebooks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-2/4-modules.html">
     2.4. Module
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-3/intro.html">
   3. Variablen, Ausdr√ºcke und Funktionsaufrufe
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-3/1-variables.html">
     3.1. Variablen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-3/2-expressions.html">
     3.2. Ausdr√ºcke
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-3/3-invoking-functions.html">
     3.3. Funktionsaufrufe
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-4/intro.html">
   4. Datentypen (Grundlagen)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/1-data-types.html">
     4.1. Pythons Datentypen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/2-int.html">
     4.2. Ganze Zahlen - int
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/3-float.html">
     4.3. Flie√ükommazahlen - float
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/4-bool.html">
     4.4. Wahrheitswerte - bool
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/5-list.html">
     4.5. Listen - list
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/6-tuple.html">
     4.6. Tupel - tuple
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/7-string.html">
     4.7. Zeichenketten - str
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/8-set.html">
     4.8. Mengen - set
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/9-dict.html">
     4.9. W√∂rterb√ºcher - dict
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/10-range.html">
     4.10. Zahlenbereich - range
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-4/11-typing-in-python.html">
     4.11. Pythons Typisierung
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-5/intro.html">
   5. Datentypen (Fortsetzung)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-5/1-type-systems.html">
     5.1. Dynamische und statische Typisierung
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-5/2-why-data-types.html">
     5.2. Existenzberechtigung
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-5/3-change-of-interpretation.html">
     5.3. Interpretationswechsel
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-5/4-kind-of-data-types.html">
     5.4. Arten von Datentypen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-5/5-primitive-data-types.html">
     5.5. Primitive Datentypen in Python?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-6/intro.html">
   6. Funktionen
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" type="checkbox"/>
  <label for="toctree-checkbox-14">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/1-purity.html">
     6.1. Reinheit
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/2-definition.html">
     6.2. Grundlagen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/3-namespaces.html">
     6.3. Namensr√§ume und Sichtbarkeit
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/4-lambdas.html">
     6.4. Anonyme Funktionen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/5-nested-functions.html">
     6.5. Umschlossene Funktionen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/x-recursion.html">
     6.6. Rekursive Funktionen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-6/6-first-class-functions.html">
     6.7. First-Class-Funktion
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-7/intro.html">
   7. Kontrollstrukturen
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" type="checkbox"/>
  <label for="toctree-checkbox-15">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-7/1-cases.html">
     7.1. Fallunterscheidungen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-7/2-loops.html">
     7.2. Schleifen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-7/3-comprehensions.html">
     7.3. Comprehensions
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03-8/intro.html">
   8. Objektorientierte Programmierung
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" type="checkbox"/>
  <label for="toctree-checkbox-16">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-8/1-class-and-objects.html">
     8.1. Klassen und Objekte
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03-8/2-inheritance-poly-encap.html">
     8.2. Vererbung, Kapselung und Polymorphie
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  CT in Aktion
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../04/robo-world.html">
   1. Roboterwelt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/dive-bell.html">
   2. Sprechen in der Taucherglocke
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/image-representation.html">
   3. Bin√§res Zeichnen - Struktur ist Information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/memory.html">
   4. Speicher - alles ist eine Liste
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../04/name-register.html">
   5. Namensregister
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Appendix
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bibliography.html">
   Bibliography
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        <a class="dropdown-buttons"
            href="../../_sources/chapters/02-1/5-hardware-equals-software.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download notebook file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/chapters/02-1/5-hardware-equals-software.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/BZoennchen/ct-book/master?urlpath=tree/chapters/02-1/5-hardware-equals-software.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#turingmaschinen">
   1.6.1. Turingmaschinen
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#die-universelle-turingmaschine">
   1.6.2. Die universelle Turingmaschine
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#das-halteproblem">
   1.6.3. Das Halteproblem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#zusammenfassung">
   1.6.4. Zusammenfassung
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="berechenbarkeit">
<span id="sec-computability"></span><h1><span class="section-number">1.6. </span>Berechenbarkeit<a class="headerlink" href="#berechenbarkeit" title="Permalink to this headline">¬∂</a></h1>
<p>In diesem Abschnitt tauchen wir in die theoretische Informatik ein und widmen uns der Frage was wir √ºberhaupt berechnen k√∂nnen (<strong>Berechenbarkeit</strong>).
In diesem Zusammenhang folgt unweigerlich die Frage: Welche Mittel ben√∂tigen wir um eines der berechenbaren Probleme zu berechnen (<strong>Turing-Vollst√§ndigkeit</strong>)?
Und was ben√∂tigen wir um jedes dieser Probleme berechnen zu k√∂nnen (<strong>universelle Turingmaschine</strong>)?</p>
<p>Beginnen wir mit einer kurzen Untersuchung von Hard- und Software, d.h., Bauteile des Computers und Programmcode.
Stellen Sie sich vor Sie haben einen Addierer als Bauteil, also als <em>Hardware</em> zur Verf√ºgung haben.
Und dass der Befehl <code class="docutils literal notranslate"><span class="pre">ladd(a,b)</span></code> diesen realisiert, d.h., die beiden Bin√§rzahlen <code class="docutils literal notranslate"><span class="pre">a</span></code> und <code class="docutils literal notranslate"><span class="pre">b</span></code> durch ein Bauteil addiert.
Wir haben gesehen, wie dies durch ein <em>Gatterzusammenschluss</em> (siehe <a class="reference internal" href="3-manipulation.html#sec-manipulation"><span class="std std-ref">Manipulation</span></a>) m√∂glich ist.</p>
<p>Um zwei Zahlen <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code> zu multiplizieren k√∂nnten wir aus mehreren Addierern einen Multiplizierer bauen.
Wir k√∂nnen also durch Komposition von bereits existierenden Bauteilen ein neues Bauteil mit einer neuen Funktion konstruieren.
Doch genauso gut k√∂nnen wir durch Programmcode den Addierer mehrfach aufrufen und erhalten so das gleiche Endergebnis.</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transformation einer Zahl in Decimaldarstellung zu ihrer Bin√§rdarstellung</span>
<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
    <span class="n">binary_number</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">number</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span>
        <span class="n">number</span> <span class="o">=</span> <span class="n">number</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">binary_number</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">binary_number</span>
    <span class="k">return</span> <span class="n">binary_number</span>

<span class="c1"># Transformation einer Zahl in Bin√§rdarstellung zu ihrer Decimaldarstellung</span>
<span class="k">def</span> <span class="nf">to_decimal</span><span class="p">(</span><span class="n">binary_number</span><span class="p">):</span>
    <span class="n">decimal_number</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">binary_number</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">binary_number</span><span class="p">:</span>
        <span class="n">decimal_number</span> <span class="o">+=</span> <span class="n">bit</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">decimal_number</span>
<span class="c1"># Zahl in Bin√§rdarstellung 111 0100 1111 wird umgewandelt</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ladd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span> <span class="c1"># Wir nehmen an diese Funktion wird durch Bauteile/Hardware umgesetzt</span>
    <span class="k">return</span> <span class="n">to_binary</span><span class="p">(</span><span class="n">to_decimal</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">to_decimal</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>  <span class="c1"># Wir nehmen an diese Funktion durch Code/Software umgesetzt</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">to_decimal</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span> <span class="c1"># Python versteht unser Bin√§rsystem nicht</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">ladd</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> * </span><span class="si">{</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">mul</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">to_decimal</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1"> * </span><span class="si">{</span><span class="n">to_decimal</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">to_decimal</span><span class="p">(</span><span class="n">mul</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[0, 0, 1, 1] * [1, 0, 0, 1] = [1, 1, 0, 1, 1]
3 * 9 = 27
</pre></div>
</div>
</div>
</div>
<p>Halten wir also fest: Wir k√∂nnen einen Multiplizierer als Bauteil konstruieren, z.B. indem wir mehrere Addierer hintereinander schalten, oder wir schreiben Programmcode der die Multiplikation durch das mehrfache Aufrufen des Addierers realisiert.
Wo liegt hierbei der Unterschied?</p>
<p>Interessiert uns nur das Ergebnis, so ist es egal welche der beiden Methoden wir verwenden.
Im Endeffekt sparen wir uns bei der zweiten Berechnung ein Bauteil.
In der Praxis spielt es allerdings eine entscheidende Rolle wie lange die Berechnung dauert.
Ein Multiplizierer der als Bauteil vorliegt, wird seine Arbeit deutlich schneller verrichten, als die Summe der Aufrufe des Addierers.
Werden bestimmte Berechnungen sehr h√§ufig ben√∂tigt, so ist es sinnvoll dar√ºber nachzudenken ob man f√ºr diese nicht extra angefertigte Bauteile anbietet.</p>
<p>Die Grafikkarte (GPU) ist ein solches Beispiel.
Theoretisch kann die <a class="reference internal" href="4-information-flow.html#def-cpu"><span class="std std-ref">CPU</span></a> all das berechnen, was die Grafikkarte berechnen kann.
Allerdings ist die Grafikkarte darauf optimiert eine bestimmte Operation auf eine Vielzahl an Daten parallel anzuwenden (Single Instruction Multiple Data).
Moderne CPUs k√∂nnen das mittlerweile auch, allerdings ist deren Parallelit√§t geringer, d.h., sie besitzen weniger Prozessorkerne.
Auch verwenden viele Grafikkarten eine weniger genaue Darstellung der Flie√ükommazahlen, da bei der Generierung von Bildern oder Animationen kleine Fehler nicht auffallen.
Moderne Grafikkarten werden wegen ihres hohen Datendurchsatzes heute f√ºr das <em>maschinelle Lernen</em> eingesetzt.
Sie haben dazu Bauteile mit denen sich die Matrixmultiplikation kleiner Matrizen sehr effizient berechnen l√§sst.</p>
<p>Software steuert die Hardware an.
Es besteht hier also eine Art Umweg.
L√∂st ein Bauteil das Problem so ist es mit sehr gro√üer Wahrscheinlichkeit schneller als jede Softwarel√∂sung.</p>
<p>Auf algorithmischer Ebene √§hneln sich Hardware und Software sehr.
Sie gleichen sich mit dem feinen Unterschied, dass Software eine bestimmte Hardware ben√∂tigt um √ºberhaupt lauff√§hig zu sein.</p>
<div class="section" id="turingmaschinen">
<h2><span class="section-number">1.6.1. </span>Turingmaschinen<a class="headerlink" href="#turingmaschinen" title="Permalink to this headline">¬∂</a></h2>
<p>Wir haben gesehen, dass der Unterschied zwischen Hard- uns Software geringer ist als wir vielleicht angenommen hatten.
Klar ist aber auch, dass ein Computer ohne Hardware nicht funktionieren wird.
Wir k√∂nnen nun die zentralen Fragen der Informatik stellen.
Salopp fragen wir:</p>
<blockquote>
<div><p>‚ÄòWie viel‚Äô Hardware braucht es denn?</p>
</div></blockquote>
<p>Oder genauer gefragt:</p>
<blockquote>
<div><p>Welche Eigenschaften muss meine Maschine haben, damit ich all das berechnen kann was berechenbar ist?</p>
</div></blockquote>
<p>Und</p>
<blockquote>
<div><p>Was k√∂nnen wir √ºberhaupt berechnen?</p>
</div></blockquote>
<p>Beide Fragen wollte Alan Turing mit seinem Berechnungsmodell, d.h., mit seiner <em>Turingmaschine</em> beantworten.</p>
<div class="figure align-default" id="fig-tm">
<a class="reference internal image-reference" href="../../_images/tm.png"><img alt="../../_images/tm.png" src="../../_images/tm.png" style="height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.13 </span><span class="caption-text">Skizze eine Turingmaschine die sich gerade in Zustand <span class="math notranslate nohighlight">\(q_4\)</span> befindet.</span><a class="headerlink" href="#fig-tm" title="Permalink to this image">¬∂</a></p>
</div>
<p>Die <a class="reference external" href="https://de.wikipedia.org/wiki/Turingmaschine">Turingmaschine (TM)</a> besteht aus gerade einmal so viel Hardware, dass sie all das berechnen kann, was allgemein als berechenbar gilt.</p>
<div class="definition admonition" id="info-turingmaschine">
<p class="admonition-title">Turingmaschine (informell)</p>
<p>Eine <em>Turingmaschine</em> <span class="math notranslate nohighlight">\(T\)</span> besteht aus:</p>
<ol class="simple">
<li><p>Einem <strong>unendlich langen Band</strong> (unendlichen Speicher) aus Zellen</p></li>
<li><p>Einem <strong>Schreib-/Lesekopf</strong></p></li>
<li><p>Einer <strong>endlichen √úbergangstabelle</strong> <span class="math notranslate nohighlight">\(\delta\)</span></p></li>
<li><p>Einer <strong>endlichen Zustandsmenge</strong> <span class="math notranslate nohighlight">\(Q\)</span></p></li>
<li><p>Eine <strong>endliche Endzustandsmenge</strong> <span class="math notranslate nohighlight">\(F \subseteq Q\)</span></p></li>
</ol>
<p>Der Schreib-/Lesekopf lie√üt oder schreibt <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span> oder <span class="math notranslate nohighlight">\(\#\)</span> in jeder Zeiteinheit an seine aktuelle Zelle auf dem Band.
Dabei steht <span class="math notranslate nohighlight">\(\#\)</span> f√ºr eine unbeschriebene Zelle, also das Leerzeichen.
Der Kopf kann zudem in einer Zeiteinheit eine Zelle nach links oder rechts fahren oder stehenbleiben.</p>
<p>Die Maschine befindet sich in einem von endlich vielen Zust√§nden.</p>
<p>Gegeben der Zustand <span class="math notranslate nohighlight">\(q\)</span> und das beim Schreib-/Lesekopf stehende Zeichen <span class="math notranslate nohighlight">\(a \in \{0, 1, \#\}\)</span>, gibt die √úbergangstabelle an:</p>
<ol class="simple">
<li><p>Den Zustand <span class="math notranslate nohighlight">\(p\)</span> den die Maschine einnimmt</p></li>
<li><p>Das Zeichen was sie aufs Band schreibt</p></li>
<li><p>Ob sich der Schreib-/Lesekopf nach links <span class="math notranslate nohighlight">\(\text{L}\)</span>, rechts <span class="math notranslate nohighlight">\(\text{R}\)</span>, oder gar nicht <span class="math notranslate nohighlight">\(\text{N}\)</span> bewegt.</p></li>
</ol>
<p>Die Turingmaschine befindet sich zu Beginn in einem Startzustand <span class="math notranslate nohighlight">\(q_0\)</span> und die Eingabe befindet sich zu beginn auf dem Band.
L√§uft die Turingmaschine irgendwann in einen Endzustand <span class="math notranslate nohighlight">\(q_e \in E\)</span>, so ist das was auf dem Band steht das berechnete Ergebnis.
Die Turingmaschine <span class="math notranslate nohighlight">\(T\)</span> berechnet <span class="math notranslate nohighlight">\(T(w)\)</span> f√ºr eine Eingabe(wort) <span class="math notranslate nohighlight">\(w\)</span>.</p>
</div>
<p>√úbertragen auf Software, bilden die endliche √úbergangstabelle <span class="math notranslate nohighlight">\(\delta\)</span> und die Zustandsmengen <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(F\)</span> ein Programm.
Diese Tabelle fassen wir auch als Funktion</p>
<div class="math notranslate nohighlight">
\[\delta : Q \times \{0, 1, \# \} \rightarrow Q \times \{0, 1, \#\} \times \{\text{L}, \text{R}, \text{N}\}\]</div>
<p>auf, wobei der Definitionsbereich und der Wertebereich endliche Mengen sind.
Befindet sich die Maschine in Zustand <span class="math notranslate nohighlight">\(q\)</span> und steht auf der aktuellen Zelle (dort wo der Schreib-/Lesekopf steht) eine 1, so liefert</p>
<div class="math notranslate nohighlight">
\[\delta(q, 1)\]</div>
<p>das was die Maschine zu tun hat, z.B., <span class="math notranslate nohighlight">\((p, 1, \text{N})\)</span>, also gehe in Zustand <span class="math notranslate nohighlight">\(p\)</span>, schreibe eine 1 und bewege deinen Kopf nicht.</p>
<p>Je nachdem was wir berechnen wollen, m√ºssen wir ein entsprechendes Programm formulieren, d.h. eine Zustandsmenge <span class="math notranslate nohighlight">\(Q\)</span> und eine √úbergangstabelle <span class="math notranslate nohighlight">\(\delta\)</span>.
Da die Turingmaschine nur sehr simple Operationen erlaubt, ist es nicht einfach ein Programm f√ºr sie zu schreiben.
Schon das Addieren von zwei Zahlen ist eine Herausforderung.
Folgende Zustandsmengen <span class="math notranslate nohighlight">\(Q = \{q_0, q_e\}, F = \{q_e\}\)</span> und <span class="math notranslate nohighlight">\(\delta\)</span>:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p><span class="math notranslate nohighlight">\(\{0, 1, \# \}\)</span></p></th>
<th class="text-align:left head"><p><span class="math notranslate nohighlight">\(Q\)</span></p></th>
<th class="text-align:right head"><p><span class="math notranslate nohighlight">\(\{0, 1, \# \}\)</span></p></th>
<th class="text-align:right head"><p><span class="math notranslate nohighlight">\(\{\text{L}, \text{R}, \text{N}\}\)</span></p></th>
<th class="text-align:right head"><p><span class="math notranslate nohighlight">\(Q\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(q_0\)</span></p></td>
<td class="text-align:right"><p>0</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\text{R}\)</span></p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(q_0\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(q_0\)</span></p></td>
<td class="text-align:right"><p>1</p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\text{R}\)</span></p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(q_0\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(\#\)</span></p></td>
<td class="text-align:left"><p><span class="math notranslate nohighlight">\(q_0\)</span></p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\#\)</span></p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(\text{R}\)</span></p></td>
<td class="text-align:right"><p><span class="math notranslate nohighlight">\(q_e\)</span></p></td>
</tr>
</tbody>
</table>
<p>berechnet das Komplement einer Bin√§rzahl.
Dabei gehen wir davon aus, dass der Schreib-/Lesekopf auf das erste Zeichen der Eingabe zeigt (links).
Die Maschine bewegt ihren Kopf einmal von links nach rechts und schreibt eine 0 wenn sie eine 1 lie√üt und eine 1 wenn sie eine 0 lie√üt.
Sobald sie ein Leerzeichen <span class="math notranslate nohighlight">\(\#\)</span> lie√üt bleibt geht sie in den Endzustand <span class="math notranslate nohighlight">\(q_e\)</span>.</p>
<div class="definition admonition" id="def-computable">
<p class="admonition-title">Allgemeine Berechenbarkeit</p>
<p>Ein Problem ist <em>berechenbar</em>, wenn f√ºr jenes Problem eine L√∂sung berechnet werden kann.</p>
</div>
<p>Der Schreib-/Lesekopf k√∂nnen wir als CPU und das Band als Speicher interpretieren.
Die Endlichkeit von <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(F\)</span> und <span class="math notranslate nohighlight">\(\delta\)</span> garantiert, dass unser Algorithmus durch endlich viel Text niedergeschrieben werden kann.
Die Turingmaschine geht davon aus, dass ihr unendlich viel Speicher zur Verf√ºgung steht.
Das stellt aber kein Problem dar, denn sofern die Maschine stehen bleibt (unser Algorithmus terminiert) kann sie nur endlich viel Zellen auf dem Band abgefahren haben.</p>
<div class="definition admonition" id="def-turing-computable">
<p class="admonition-title">Turing-Berechenbarkeit</p>
<p>Ein Problem ist genau dann <em>Turing-berechenbar</em>, wenn eine Turingmaschine existiert, die bei jeder Eingabe h√§lt und die L√∂sung bei entsprechender Eingabe berechnet.</p>
</div>
<p>Die Probleme die wir mit der <em>Turingmaschine</em> berechnen k√∂nnen, bilden eine gewisse Problemklasse.
Nach der unbeweisbaren <em>Turing-Church-These</em> handelt es sich bei diesen Problemen um all diejenigen die im <a class="reference internal" href="#def-computable"><span class="std std-ref">allgemeinen berechenbar</span></a> sind.
Das hei√üt eine <em>Turingmaschine</em> kann alles berechnen was wir vermutlich allgemein berechnet k√∂nnen.</p>
<div class="conjecture admonition" id="def-church-these">
<p class="admonition-title">Turing-Church-These (unbeweisbar)</p>
<p>Ein Problem ist genau dann <em>berechenbar</em>, wenn es auch <em>Turing-berechenbar</em> ist.</p>
</div>
<p>Nehmen wir an die <em>Turing-Church-These</em> trifft zu, so wissen wir was <strong>berechenbar</strong> ist und wie viel Hardware es braucht!
Wir brauchen soviel Hardware, dass unser Computer all das kann was eine <em>Turingmaschine</em> kann.</p>
<p>Alan Turing definierte den Begriff der <em>Turing-Vollst√§ndigkeit</em>.
Eine Rechenmaschine die <em>Turing-vollst√§ndig</em> ist, kann all das berechnen was eine Turingmaschine berechnen kann.</p>
<div class="definition admonition" id="def-turing-complete">
<p class="admonition-title">Turing-Vollst√§ndigkeit</p>
<p>Eine Rechenmaschine (oder Programmiersprache) ist <em>Turing-vollst√§ndig</em> genau dann wenn sie all das berechnen kann was eine Turingmaschine berechnen kann.</p>
</div>
<p>Wenn Sie also verstehen m√∂chten, ‚Äòwie viel Hardware‚Äô ein Computer braucht, lohnt sich ein Blick hin zur Turingmaschine.
Uns ist klar, dass es sich dabei um ein sehr theoretisches Konstrukt handelt.
Wir ersparen Ihnen die formale Definition und m√∂chten Sie dennoch best√§rken ein intuitives Verst√§ndnis √ºber die Turingmaschine w√§hrend Ihres Studiums aufzubauen.</p>
<p>Die Turingmaschine kommt mit erstaunlich wenig Hardware aus.
Ein pfiffige Bastler*innen k√∂nnen diese Maschine als Heimwerkerprojekt im Keller bauen.
Es steht ihnen zwar kein unendliches Band zur Verf√ºgung doch falls ein Algorithmus terminiert, kann der Schreib-/Lesekopf nur eine endliche Distanz fahren und somit ist ein endliches Band ausreichend.
Wie lange dies jedoch sein muss ist im Vornhinein unklar.</p>
<div class="figure align-default" id="model-of-a-tm-2">
<a class="reference internal image-reference" href="../../_images/model-of-a-tm.jpeg"><img alt="../../_images/model-of-a-tm.jpeg" src="../../_images/model-of-a-tm.jpeg" style="height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1.14 </span><span class="caption-text">Eine konkrete Konstruktion einer Turingmaschine.</span><a class="headerlink" href="#model-of-a-tm-2" title="Permalink to this image">¬∂</a></p>
</div>
</div>
<div class="section" id="die-universelle-turingmaschine">
<span id="sec-utm"></span><h2><span class="section-number">1.6.2. </span>Die universelle Turingmaschine<a class="headerlink" href="#die-universelle-turingmaschine" title="Permalink to this headline">¬∂</a></h2>
<p>Bis heute k√∂nnen wir jedes berechenbare Problem durch eine bestimmte Turingmaschine berechnen.
Nat√ºrlich m√ºssen wir eine <em>Turingmaschine</em> f√ºr das jeweilige Problem konstruieren.
Ein Computer l√∂st aber nicht nur ein bestimmtes Problem, sondern ist im Stande <strong>jedes</strong> Problem, was durch eine Turingmaschine gel√∂st werden kann zu berechnen.</p>
<p>Ein Computer ist das Pendant zu einer ganz bestimmten Turingmaschine, der <em>universellen Turingmaschine (UTM)</em>.
Die universelle Turingmaschine <span class="math notranslate nohighlight">\(U\)</span> (Computer) erh√§lt als Eingabe eine Beschreibung einer andere Turingmaschine <span class="math notranslate nohighlight">\(\alpha_T\)</span> (Programm) und die Eingabe(wort) <span class="math notranslate nohighlight">\(w\)</span> der Turingmaschine <span class="math notranslate nohighlight">\(T\)</span>.
Sie simuliert <span class="math notranslate nohighlight">\(T\)</span> unter der Eingabe <span class="math notranslate nohighlight">\(w\)</span></p>
<div class="math notranslate nohighlight">
\[U(\alpha_T, w) = T(w)\]</div>
<p>Das hei√üt die universelle Turingmaschine <span class="math notranslate nohighlight">\(U\)</span> berechnet das was die Turingmaschine <span class="math notranslate nohighlight">\(T\)</span> berechnen w√ºrde, indem Sie diese simuliert.</p>
<p>Da eine Turingmaschine <span class="math notranslate nohighlight">\(T\)</span> durch <span class="math notranslate nohighlight">\(\delta\)</span>, <span class="math notranslate nohighlight">\(Q\)</span> und <span class="math notranslate nohighlight">\(F\)</span> vollst√§ndig beschrieben ist und all diese Mengen endlich sind, ist sichergestellt dass auch <span class="math notranslate nohighlight">\(\alpha_T\)</span> endlich ist.
Der Repr√§sentant von <span class="math notranslate nohighlight">\(\alpha_T\)</span> muss ein Bin√§rcode sein, sodass wir ihn auf das Band von <span class="math notranslate nohighlight">\(U\)</span> schreiben k√∂nnen.
Wie <span class="math notranslate nohighlight">\(U\)</span> genau aussieht werden wir uns nicht ansehen.
Sie k√∂nnen sich denken, dass die √úbergangstabelle von <span class="math notranslate nohighlight">\(U\)</span> sehr gro√ü ist.</p>
<div class="definition admonition" id="info-universal-turing-machine">
<p class="admonition-title">Universelle Turingmaschine (informell)</p>
<p>Eine <em>universelle Turingmaschine</em> <span class="math notranslate nohighlight">\(U\)</span> ist eine Turingmaschine, die eine beliebige Turingmaschine <span class="math notranslate nohighlight">\(T\)</span> auf beliebiger Eingabe <span class="math notranslate nohighlight">\(w\)</span> simuliert.</p>
</div>
</div>
<div class="section" id="das-halteproblem">
<h2><span class="section-number">1.6.3. </span>Das Halteproblem<a class="headerlink" href="#das-halteproblem" title="Permalink to this headline">¬∂</a></h2>
<p>Das Halteproblem ist eines der bekanntesten Probleme der Informatik, da es wesentliche Implikationen √ºber die M√§chtigkeit von Computern offenlegt.
Wir w√ºrden uns als Programmierer*innen w√ºnschen, dass es Programm g√§be, dass uns f√ºr ein anderes beliebiges Programm mit einer bestimmten Eingabe verr√§t ob dieses auch halten wird oder ob wir in einer Endlosschleife laufen.</p>
<div class="definition admonition" id="def-halting-problem">
<p class="admonition-title">Das Halteproblem</p>
<p>Gegeben eine Beschreibung <span class="math notranslate nohighlight">\(\alpha_T\)</span> einer Turingmaschine <span class="math notranslate nohighlight">\(T\)</span> und deren Eingabe <span class="math notranslate nohighlight">\(w\)</span>, so verlangt das Halteproblem, nach der Antwort der Frage ob <span class="math notranslate nohighlight">\(T(w)\)</span> h√§lt oder nicht.</p>
</div>
<p>Leider hat sich herausgestellt, dass das Halteproblem nicht berechenbar ist.</p>
<div class="theorem admonition" id="theorem-halting-problem-theorem">
<p class="admonition-title">Unberechenbarkeit des Halteproblems</p>
<p>Das Halteproblem ist nicht berechenbar.</p>
</div>
<p>Wir k√∂nnen nat√ºrlich <span class="math notranslate nohighlight">\(T(w)\)</span> ausf√ºhren und einfach abwarten ob die Turingmaschine <span class="math notranslate nohighlight">\(T\)</span> h√§lt oder nicht.
Wenn sie aber nicht h√§lt, k√∂nnen wir das niemals feststellen ‚Äì wir m√ºssten unendlich lange warten.</p>
<p>Das bedeutet: Es wird niemals einen Algorithmus geben (geschrieben in einer Turing-vollst√§ndigen Sprache), welcher f√ºr beliebige Programme pr√ºfen kann ob diese auch terminieren.
Das bedeutet jedoch nicht, dass wir dies nicht im Einzelfall selbst pr√ºfen k√∂nnen oder das es Programme gibt, die f√ºr viele Programme pr√ºfen k√∂nnen ob diese terminieren.
Es gibt also Hoffnung.</p>
</div>
<div class="section" id="zusammenfassung">
<span id="sec-essenz-of-computers-and-languages"></span><h2><span class="section-number">1.6.4. </span>Zusammenfassung<a class="headerlink" href="#zusammenfassung" title="Permalink to this headline">¬∂</a></h2>
<p>Weshalb reiten wir so auf diesen theoretischen Konzepten herum?
Was k√ºmmern uns imagin√§re Turingmaschinen?
Diese Maschinen k√∂nnen zwar all das berechnen was ein Computer berechnet, funktionieren aber doch ganz anders.
Insbesondere sind sie extrem langsam.</p>
<p>Computer und Programmiersprachen sind Werkzeuge um unsere Konzepte welche durch <a class="reference internal" href="../01-2/what-is-ct.html#sec-what-is-ct"><span class="std std-ref">Computational Thinking</span></a> entstehen zu realisieren.
Was aber k√∂nnen wir √ºberhaupt mit diesen Werkzeugen realisieren?
Die Antwort folgt aus der eben besprochenen Turingmaschine, denn jeder Ihnen bekannte Computer und jede Programmiersprache welche Sie erlernen werden ist <a class="reference internal" href="#def-turing-complete"><span class="std std-ref">Turing-vollst√§ndig</span></a>!</p>
<p>Jeder Computer kann genau das berechnen, was eine Turingmaschine berechnen kann.
Selbstverst√§ndlich arbeiten Computer mit vollkommen anderen Bauteilen, was sie viel effizienter macht.
Im wesentlichen sind sie dennoch nichts anderes als effiziente Turingmaschinen.
John von Neumann‚Äôs Prinzip des <a class="reference internal" href="4-information-flow.html#sec-von-neumann"><span class="std std-ref">speicherprogrammierten Computers</span></a> basiert auf Alan Turing‚Äôs Turingmaschine.</p>
<p>F√ºr alle g√§ngigen Programmiersprachen gilt, dass Sie mit ihnen Algorithmen formulieren k√∂nnen, die eine L√∂sung berechnen, welche auch von einer <em>Turingmaschine</em> berechnet werden kann!</p>
<div class="exercise admonition" id="programming-languages-turing-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 1.15 </span>(Kompilieren und Interpretieren)</p>
<div class="section" id="exercise-content">
<p>Angenommen Sie haben zwei Turing-vollst√§ndige Programmiersprachen <code class="docutils literal notranslate"><span class="pre">A</span></code> und <code class="docutils literal notranslate"><span class="pre">B</span></code>.
K√∂nnen Sie mit der Sprache <code class="docutils literal notranslate"><span class="pre">A</span></code> ein Programm <code class="docutils literal notranslate"><span class="pre">a</span></code> schreiben, welches Programmcode <code class="docutils literal notranslate"><span class="pre">b</span></code> der Sprache <code class="docutils literal notranslate"><span class="pre">B</span></code> f√ºr eine beliebige Eingabe simuliert?</p>
</div>
</div>
<div class="solution dropdown admonition" id="programming-languages-turing-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#programming-languages-turing-exercise"><span>Exercise 1.15</span></a></p>
<div class="section" id="solution-content">
<p>Ja das ist m√∂glich!</p>
<ol class="simple">
<li><p><strong>Kompilieren</strong>: Da beide Sprachen Turing-vollst√§ndig sind, k√∂nnen Sie ein Programm in der Sprache <code class="docutils literal notranslate"><span class="pre">B</span></code> schreiben was den Programmcode <code class="docutils literal notranslate"><span class="pre">b</span></code> in einen Programmcode <code class="docutils literal notranslate"><span class="pre">a</span></code> der Sprache <code class="docutils literal notranslate"><span class="pre">A</span></code> √ºberf√ºhrt, sodass <code class="docutils literal notranslate"><span class="pre">a</span></code> das gleiche berechnet wie <code class="docutils literal notranslate"><span class="pre">b</span></code>. Diesen Vorgang nennen wir <em>kompilieren</em>.</p></li>
<li><p><strong>Interpretieren</strong>: Wir k√∂nnen auch fortw√§hrend ein Programm <code class="docutils literal notranslate"><span class="pre">a</span></code> in <code class="docutils literal notranslate"><span class="pre">A</span></code> immer wieder schreiben, welches die n√§chsten <span class="math notranslate nohighlight">\(n\)</span> Befehle von <code class="docutils literal notranslate"><span class="pre">b</span></code> simuliert, d.h. den Code in <code class="docutils literal notranslate"><span class="pre">b</span></code> Schritt f√ºr Schritt ausf√ºhrt.</p></li>
</ol>
</div>
</div>
<p>Man muss sich vor Augen halten, dass Alan Turing bereits 1936 die Grundlagen f√ºr alle modernen Computer und Programmiersprachen dieser Welt gelegt hat.</p>
<p>Gehen wir nun zur√ºck zur Frage nach dem Unterschied zwischen Hard-/ und Software.
Der wesentlichen Unterschied zwischen dem Computer (Hardware) und einem Programm (Software) ist die Art und Weise wie die <a class="reference internal" href="#def-turing-complete"><span class="std std-ref">Turing-vollst√§ndig</span></a> realisiert wird ‚Äì durch elektrische Bauteile oder einer Programmiersprache.</p>
<p>Programme als auch Computer sind Turingmaschinen und da der Computer Programme, also andere Turingmaschinen, simuliert ist er eine
<a class="reference internal" href="#info-universal-turing-machine"><span class="std std-ref">universelle Turingmaschine</span></a>.</p>
<div class="remark admonition" id="computer-universal-turing">
<p class="admonition-title">Computer sind universelle Turingmaschinen</p>
<p>Ein handels√ºblicher Computer ist eine universelle Turingmaschine.</p>
</div>
<p>Sobald ein Computer Turing-vollst√§ndig ist, sind alle weiteren Bauteile ein Bonus.
In der Theorie ist die universelle Turingmaschine ebenso ‚Äòschnell‚Äô wie ein moderner Computer.
In der Praxis w√§re sie allerdings unfassbar langsam.
In der Theorie ist sogar jeder Prozessor ‚Äògleich schnell‚Äô.
In der Praxis ist das nat√ºrlich nicht der Fall.
Die Turingmaschine hilft uns dabei die Begriffe <em>schnell</em>, <em>schneller</em> und <em>langsamer</em> und <em>gleich schnell</em> formal zu definieren.
Wir werden in Abschnitt <span class="xref myst">Komplexit√§tstheorie</span> sehen, dass diese Komplexit√§tsklassen uns etwas √ºber die Schwierigkeit eines Problems verraten, doch in der Praxis mit Vorsicht zu genie√üen sind.</p>
<p>Zus√§tzliche oder effizientere Hardware dient im wesentlichen der Beschleunigung bestimmter Berechnungen.
Ein Beispiel, was wir oben bereits besprochen haben ist die Grafikkarte (GPU).
In der Theorie ist sie sogar <em>genauso schnell</em> wie eine CPU.
Dennoch hat jeder g√§ngige Heim-Computer eine Grafikkarte, da diese f√ºr Berechnungen im 3D-Grafikbereich optimiert ist.</p>
<p>Wichtig ist festzuhalten, dass sich Hardware und Software auf konzeptioneller Ebene gleichen.
Hardware ist die Manifestation von Software und Software ist die Manifestation des Computational Thinkings und so entspringt auch Hardware aus dem Computational Thinking!</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "BZoennchen/ct-book",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters/02-1"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="4-information-flow.html" title="previous page"><span class="section-number">1.5. </span>Der Informationskreislauf</a>
    <a class='right-next' id="next-link" href="../02-2/information.html" title="next page"><span class="section-number">2. </span>Was ist Information?</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Benedikt Z√∂nnchen, Sarah Ottinger, Martin Hobelsberger<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>