
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>5. Namensregister &#8212; Computational Thinking</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet" />
  <link href="../../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.acff12b8f9c144ce68a297486a2fa670.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/tabs.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Bibliography" href="../misc/bibliography.html" />
    <link rel="prev" title="4. Speicher - alles ist eine Liste" href="memory.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
      <img src="../../_static/logo-HM.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Computational Thinking</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Computational Thinking
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Einleitung
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../01/course.html">
   1. Kurskonzept
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../01/1-teaching.html">
     1.1. Lehrkonzept
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../01/2-learn-how-to-think.html">
     1.2. Denken lernen?
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../02/what-is-ct.html">
   2. Was ist Computational Thinking
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../02/1-informatics-and-ct.html">
     2.1. Von der Informatik zum Computational Thinking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../02/2-repetition-is-the-key.html">
     2.2. Wiederholung als Grundlage
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../03/history.html">
   3. Geschichte der Computer und Algorithmen
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../03/1-ancient.html">
     3.1. Antike
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03/2-middleages.html">
     3.2. Mittelalter bis 19. Jahrundert
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03/3-today.html">
     3.3. 19. Jahrundert bis heute
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../03/4-future.html">
     3.4. Ausblick
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../04/why-ct.html">
   4. Warum Computational Thinking?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../04/1-intrinsic-value.html">
     4.1. Intrinsischer Wert
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../04/2-usefulness.html">
     4.2. Langfristiger Nutzen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../04/3-self-determination.html">
     4.3. Selbstbestimmt durch CT
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../05/sorting.html">
   5. Lasst uns Denken
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../05/1-sort-cards.html">
     5.1. Karten sortieren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../05/2-sort-cards-with-python.html">
     5.2. Karten sortieren in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../05/3-sort-numbers.html">
     5.3. Zahlen sortieren in Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../05/4-sort-anything.html">
     5.4. Allgemeines Sortieren in Python
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Theorie
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../06/information-processing.html">
   1. Der digitale Computer
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../06/1-basics.html">
     1.1. Grundlagen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../06/2-interpretation.html">
     1.2. Interpretation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../06/2-representation.html">
     1.3. Repräsentationen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../06/3-manipulation.html">
     1.4. Manipulation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../06/4-information-flow.html">
     1.5. Der Informationskreislauf
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../06/5-hardware-equals-software.html">
     1.6. Berechenbarkeit
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../07/information.html">
   2. Was ist Information?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../07/1-natural-science.html">
     2.1. Naturwissenschaften
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../07/2-formal-science.html">
     2.2. Strukturwissenschaften
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../07/3-critic.html">
     2.3. Kritik
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../07/4-humanics.html">
     2.4. Geisteswissenschaften
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../07/5-summary.html">
     2.5. Zusammenfassung
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../08/languages.html">
   3. Programmiersprachen
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../08/1-abstraction.html">
     3.1. Abstraktion des Computers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../08/2-success-criteria.html">
     3.2. Erfolgsfaktoren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../08/3-imperative-vs-functional.html">
     3.3. Imperativ vs. funktional
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../08/4-language-evolution.html">
     3.4. Sprachevolution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../08/5-python.html">
     3.5. Python
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../08/6-diversity.html">
     3.6. Diversität
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../09/the-art-of-programming.html">
   4. Die Kunst des Programmierens
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../09/1-algorithms.html">
     4.1. Algorithmen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../09/2-programming.html">
     4.2. Programmieren
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../09/3-code.html">
     4.3. Programmiercode
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Python
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../10/programming-in-python.html">
   1. Programmieren in Python
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../10/1-jupyter-notebooks.html">
     1.1. Jupyter Notebooks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10/2-variables.html">
     1.2. Variablen
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10/3-expressions.html">
     1.3. Ausdrücke
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10/4-invoking-functions.html">
     1.4. Funktionsaufrufe
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../10/5-data-types.html">
     1.5. Datentypen
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  CT in Aktion
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="robo-world.html">
   1. Roboterwelt
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="dive-bell.html">
   2. Sprechen in der Taucherglocke
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="image-representation.html">
   3. Binäres Zeichnen - Struktur ist Information
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="memory.html">
   4. Speicher - alles ist eine Liste
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   5. Namensregister
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Appendix
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bibliography.html">
   Bibliography
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/chapters/11/name-register.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#binare-suche-im-telefonbuch">
   5.1. Binäre Suche im Telefonbuch
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#informelle-beschreibung">
     5.1.1. Informelle Beschreibung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#formale-beschreibung">
     5.1.2. Formale Beschreibung
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#algorithmische-beschreibung">
     5.1.3. Algorithmische Beschreibung
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#facher-und-markierungen">
   5.2. Fächer und Markierungen
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eine-csv-datei-lesen">
     5.2.1. Eine CSV Datei lesen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#zahlen-von-doppelten-eintragen">
     5.2.2. Zählen von doppelten Einträgen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ordnung-durch-facher">
     5.2.3. Ordnung durch Fächer
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#ordnung-durch-markierungen">
     5.2.4. Ordnung durch Markierungen
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#hashing-und-das-dictionary">
   5.3. Hashing und das Dictionary
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#geschlossenes-hashing">
     5.3.1. Geschlossenes Hashing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hashfunktionen">
     5.3.2. Hashfunktionen
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#die-build-in-hashfunktion">
     5.3.3. Die Build-in Hashfunktion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#eine-eigene-gute-hashfunktion">
     5.3.4. Eine eigene gute Hashfunktion
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unser-dictionary">
     5.3.5. Unser Dictionary
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hashtable-klasse-optional">
     5.3.6. Hashtable Klasse (optional)
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="namensregister">
<span id="sec-name-register"></span><h1><span class="section-number">5. </span>Namensregister<a class="headerlink" href="#namensregister" title="Permalink to this headline">¶</a></h1>
<p>Sie kennen womöglich gar keinen ausgedruckten Namensregister mehr.
Vor langer langer Zeit in einer weit entfernten Galaxie gab es noch so etwas wie Telefonbücher und zwar als wirkliches reales Buch!
In einem solchen Buch standen die Telefonnummern der Menschen, welche in einem bestimmten Ort wohnen.</p>
<div class="learngoals admonition">
<p class="admonition-title">Lernziel</p>
<p>TODO</p>
</div>
<p>Ein Telefonbuch liefert Ihnen für einen gegebenen Namen die zugehörige Telefonnummer der Familie oder Person.
Falls es keine zwei Personen mit dem gleichen Haushalt gibt, so können wir das Telefonbuch als mathematische Funktion interpretieren.
Der Definitionsbereich sind die Namen der Haushalte und der Wertebereich ist die Menge zugehörigen Telefonnummern.</p>
<p>Warum ist ein Buch voller Namen und Telefonnummern nützlich?
Welche wesentliche Eigenschaft des Telefonbuchs macht es nützlich?</p>
<div class="exercise admonition" id="telefonnr-property-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.5 </span>(Eigenschaft des Telefonbuch)</p>
<div class="section" id="exercise-content">
<p>Aufgrund welcher Eigenschaft finden wir im Telefonbuch eine Telefonnummer recht schnell?</p>
</div>
</div>
<div class="solution dropdown admonition" id="telefonnr-property-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#telefonnr-property-exercise"><span>Exercise 5.5</span></a></p>
<div class="section" id="solution-content">
<p>Das Telefonbuch ist eine nach Namen <strong>sortierte Liste</strong> von Einträgen!</p>
</div>
</div>
<div class="section" id="binare-suche-im-telefonbuch">
<h2><span class="section-number">5.1. </span>Binäre Suche im Telefonbuch<a class="headerlink" href="#binare-suche-im-telefonbuch" title="Permalink to this headline">¶</a></h2>
<div class="section" id="informelle-beschreibung">
<h3><span class="section-number">5.1.1. </span>Informelle Beschreibung<a class="headerlink" href="#informelle-beschreibung" title="Permalink to this headline">¶</a></h3>
<p>Wenn wir in einer solchen <strong>sortierten Liste</strong> nach einem Eintrag suchen gehen wir intuitiv anders vor als wenn die Liste unsortiert wäre.
Im Fall der unsortierten Liste bleibt uns nichts anderes übrig als die Liste von vorne bis hinten zu durchsuchen (<a class="reference internal" href="dive-bell.html#def-linear-search"><span class="std std-ref">lineare Suche</span></a>).</p>
<div class="exercise admonition" id="telefonnr-search-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.6 </span>(Suchen im Telefonbuch)</p>
<div class="section" id="exercise-content">
<p>Beschreiben Sie informell, wie Sie nach der Telefonnummer von Fr. <code class="docutils literal notranslate"><span class="pre">Reichel</span></code> suchen.</p>
</div>
</div>
<div class="solution dropdown admonition" id="telefonnr-search-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#telefonnr-search-exercise"><span>Exercise 5.6</span></a></p>
<div class="section" id="solution-content">
<p>Wir schätzen erst ab wo die Namen mit dem Buchstaben <code class="docutils literal notranslate"><span class="pre">R</span></code> beginnen.
Wir schlagen das Buch recht weit hinten auf und betrachten den ersten und letzten Namen der Seite.
Kommt der erste Name vor, und der letzte Name nach <code class="docutils literal notranslate"><span class="pre">Reichel</span></code> so suchen wir den Namen auf der Seite.</p>
<p>Kommt der erste Name nach <code class="docutils literal notranslate"><span class="pre">Reichel</span></code>, finden wir den Namen im vorderen Teil des Buches.
Kommt der letzte Name vor <code class="docutils literal notranslate"><span class="pre">Reichel</span></code>, finden wir den Namen im hintern Teil des Buches.</p>
<p>Wir nehmen den entsprechenden Teil und schlagen die Seite in der Mitte dieses Teils auf.
Den anderen Teil werden wir nie wieder betrachten.</p>
<p>Diesen Prozess wiederholen wir bis wir die entsprechende Seite gefunden haben.
Dann können wir entweder den Namen auf der Seite mit einer <a class="reference internal" href="dive-bell.html#def-linear-search"><span class="std std-ref">linearen Suche</span></a> auffinden oder die gleiche <a class="reference internal" href="dive-bell.html#def-binary-search"><span class="std std-ref">binäre Suche</span></a> mit den Namen auf der Seite vollziehen.</p>
</div>
</div>
<p>Im Abschnitt <a class="reference internal" href="dive-bell.html#sec-dive-bell"><span class="std std-ref">Sprechen in der Taucherglocke</span></a> haben wir unter <a class="reference internal" href="dive-bell.html#sec-dive-bell-binary-search"><span class="std std-ref">Suchalgorithmen</span></a> bereits diese sogenannte <a class="reference internal" href="dive-bell.html#def-binary-search"><span class="std std-ref">binäre Suche</span></a> angewendet.
Wir möchten an dieser Stelle ein wenig Formalismus einbringen um eine eindeutigere Beschreibung der <a class="reference internal" href="dive-bell.html#def-binary-search"><span class="std std-ref">binäre Suche</span></a> zu erhalten.
Wie jede neue Sprache kann der Formalismus abschreckend wirken, doch bietet er ähnlich wie die Programmiersprachen eine Möglichkeit sich unmissverständlich auszudrücken.</p>
</div>
<div class="section" id="formale-beschreibung">
<h3><span class="section-number">5.1.2. </span>Formale Beschreibung<a class="headerlink" href="#formale-beschreibung" title="Permalink to this headline">¶</a></h3>
<p>Bei dieser Gelegenheit stellen wir Ihnen ein häufig verwendetes Konstrukt, den sog. <strong>Komperator</strong>, vor.
Sei also <span class="math notranslate nohighlight">\(E\)</span> eine Menge von möglichen Einträgen.
Sei <span class="math notranslate nohighlight">\(\mathcal{L} = (e_0, \ldots, e_n), e_i \in E\)</span> ein (geordnetes) Tupel.
Sei</p>
<div class="math notranslate nohighlight" id="equation-name-register-eq-1">
<span class="eqno">(5.1)<a class="headerlink" href="#equation-name-register-eq-1" title="Permalink to this equation">¶</a></span>\[f_E : E \times E \rightarrow \{-1,0,1 \}\]</div>
<p>eine (Komparator-)Funktion (Comparator) oder kurz <strong>Komparator</strong> bezüglich <span class="math notranslate nohighlight">\(E\)</span>.
Dieser vergleicht zwei Elemente <span class="math notranslate nohighlight">\(e_i, e_j \in E\)</span> sodass</p>
<div class="math notranslate nohighlight" id="equation-name-register-eq-2">
<span class="eqno">(5.2)<a class="headerlink" href="#equation-name-register-eq-2" title="Permalink to this equation">¶</a></span>\[\begin{split}f_E(e_i, e_j) = 
\begin{cases}
-1, &amp; \quad \text{falls } e_i &lt; e_j\\
+1, &amp; \quad \text{falls } e_i &gt; e_j\\
+0, &amp; \quad \text{sonst}.
\end{cases}\end{split}\]</div>
<p>Aus <span class="math notranslate nohighlight">\(f_E\)</span> lassen sich die Vergleichsoperatoren rekonstruieren:</p>
<div class="amsmath math notranslate nohighlight" id="equation-392c362d-cefd-4524-9551-2fc1a8502e58">
<span class="eqno">(5.3)<a class="headerlink" href="#equation-392c362d-cefd-4524-9551-2fc1a8502e58" title="Permalink to this equation">¶</a></span>\[\begin{gather}
e_i &lt; e_j \iff f(e_i, e_j) = -1 \\
e_i = e_j \iff f(e_i, e_j) = +0 \\
e_i &gt; e_j \iff f(e_i, e_j) = +1.
\end{gather}\]</div>
<p>Für das Tupel nehmen wir an dass</p>
<div class="math notranslate nohighlight" id="equation-name-register-eq-3">
<span class="eqno">(5.4)<a class="headerlink" href="#equation-name-register-eq-3" title="Permalink to this equation">¶</a></span>\[f_E(e_i, e_j) \leq 0 \iff i &lt; j,\]</div>
<p>das heißt, das Tupel ist sortiert. Wir suchen nun ein Element <span class="math notranslate nohighlight">\(e \in E\)</span>.
Schrittweise zerteilen wir Liste oder das Tupel <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> in zwei gleiche Hälften und wählen eine davon.
Dabei passen wir das Intervall <span class="math notranslate nohighlight">\(I = [a;b]\)</span> der Listenindices an, welche diese Hälften definieren.</p>
<p>Wir beginnen mit <span class="math notranslate nohighlight">\(a_0 = 0, b_0 = |\mathcal{L}|-1\)</span> und berechnen ein Pivotindex</p>
<div class="math notranslate nohighlight">
\[k_0 = a_0 + \left \lfloor{(b_0 - a_0) / 2}\right \rfloor\]</div>
<p>Dabei ist <span class="math notranslate nohighlight">\(\left \lfloor{\cdot}\right \rfloor\)</span> das Abrunden.
Falls das Pivotelement <span class="math notranslate nohighlight">\(e_{k_0}\)</span> gleich dem gesuchten Element <span class="math notranslate nohighlight">\(e\)</span> ist also</p>
<div class="math notranslate nohighlight">
\[f_E(e, e_{k_0}) = 0,\]</div>
<p>sind wir fertig. Ansonsten passen wir das Suchintervall <span class="math notranslate nohighlight">\(I_0 = [a_0;b_0]\)</span> wie folgt an:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
a_1 = \begin{cases}
k_0+1, &amp; \quad \text{falls } f_E(e, e_{k_0}) = 1\\
a_0, &amp; \quad \text{sonst}
\end{cases}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
b_1 = \begin{cases}
k_0-1, &amp; \quad \text{falls } f_E(e, e_{k_0}) = -1\\
b_0, &amp; \quad \text{sonst}
\end{cases}
\end{split}\]</div>
<p>Wir haben ein neues Intervall <span class="math notranslate nohighlight">\(I_1 = [a_1;b_1]\)</span> und wiederholen die Schritte für die Intervallanpassung bis für irgendeine Iteration <span class="math notranslate nohighlight">\(j\)</span></p>
<div class="math notranslate nohighlight">
\[e_{k_j} = e\]</div>
<p>oder</p>
<div class="math notranslate nohighlight">
\[a_j &lt; b_j\]</div>
<p>gilt.</p>
<div class="figure align-default" id="fig-binary-search">
<a class="reference internal image-reference" href="../../_images/binary-search.png"><img alt="../../_images/binary-search.png" src="../../_images/binary-search.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.2 </span><span class="caption-text">Binäre Suche nach dem Element <span class="math notranslate nohighlight">\(e = 8\)</span> in einer sortierten Liste <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> aus Zahlen.</span><a class="headerlink" href="#fig-binary-search" title="Permalink to this image">¶</a></p>
</div>
<div class="hint dropdown admonition">
<p class="admonition-title">Zuweisung (Notation)</p>
<p>Falls wir uns der mathematischen Schreibweise bedienen vermeiden wir die Zuweisung über das <span class="math notranslate nohighlight">\(=\)</span> Zeichen.
<span class="math notranslate nohighlight">\(a = 2\)</span> bedeutet, dass <span class="math notranslate nohighlight">\(a\)</span> gleich <span class="math notranslate nohighlight">\(2\)</span> ist.
Der Ausdruck</p>
<div class="math notranslate nohighlight">
\[a = a + 2\]</div>
<p>macht keinen Sinn bzw. ist eine falsche Aussage.
Oben haben wir stattdessen viele Variablen verwendet also</p>
<div class="math notranslate nohighlight">
\[a_1 = a_0 + 2.\]</div>
<p>Stattdessen können wir auch einen anderen Operator verwenden.
Üblich ist</p>
<div class="math notranslate nohighlight">
\[a \leftarrow a + 2.\]</div>
</div>
<p>Lassen Sie uns ein Beispiel durchgehen.
Angenommen wir haben eine Liste mit <span class="math notranslate nohighlight">\(100\)</span> Zahlen und wir suchen die Zahl <span class="math notranslate nohighlight">\(e_i\)</span> mit dem Index <span class="math notranslate nohighlight">\(i = 66\)</span>.
So ist folgende Sequenz die Sequenz der Intervalle:</p>
<div class="math notranslate nohighlight">
\[[0;99], [50;99], [50;73], [62;73], [62;66], [65;66], [66;66]\]</div>
<div class="exercise admonition" id="binary-search-interval-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.7 </span>(Binäre Suchen - Intervalle)</p>
<div class="section" id="exercise-content">
<p>Bestimmen Sie die Squenz der Intervalle für eine Liste mit <span class="math notranslate nohighlight">\(150\)</span> Elementen und <span class="math notranslate nohighlight">\(i = 48\)</span>.</p>
</div>
</div>
<div class="solution dropdown admonition" id="binary-search-interval-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#binary-search-interval-exercise"><span>Exercise 5.7</span></a></p>
<div class="section" id="solution-content">
<div class="math notranslate nohighlight">
\[[0;149], [0;73], [37;73], [37;54], [46;54], [46;49], [48;49]\]</div>
</div>
</div>
</div>
<div class="section" id="algorithmische-beschreibung">
<h3><span class="section-number">5.1.3. </span>Algorithmische Beschreibung<a class="headerlink" href="#algorithmische-beschreibung" title="Permalink to this headline">¶</a></h3>
<p>Die wesentliche Eigenschaft welche die <a class="reference internal" href="dive-bell.html#def-binary-search"><span class="std std-ref">binäre Suche</span></a> ausnutzt sind in Gleichungen <a class="reference internal" href="#equation-name-register-eq-1">(5.1)</a>, <a class="reference internal" href="#equation-name-register-eq-2">(5.2)</a> und <a class="reference internal" href="#equation-name-register-eq-3">(5.4)</a> zusammengefasst.
Wir benötigen eine <a class="reference internal" href="../05/1-sort-cards.html#def-order"><span class="std std-ref">Ordnung</span></a>, sodass es einen Komparator <span class="math notranslate nohighlight">\(f_E\)</span> gibt.
Das Tupel bzw. unsere Liste muss sortiert sein <a class="reference internal" href="#equation-name-register-eq-3">(5.4)</a>.</p>
<p>Der Komparator <span class="math notranslate nohighlight">\(f_E\)</span> wird passend zur Menge der möglichen Listelemente <span class="math notranslate nohighlight">\(E\)</span> definiert, d.h. je nachdem welche Art von Liste (Namensliste, Telefonbucheinträge, Zahlen, Klausuren) wir vorfinden, müssen wir ein geeignetes <span class="math notranslate nohighlight">\(f_E\)</span> konstruieren.</p>
<p>Zum Beispiel ist für die Klausuren <span class="math notranslate nohighlight">\(f_E(e_i, e_j)\)</span> gleich <span class="math notranslate nohighlight">\(-1\)</span> wenn der Name des Studierenden der Klausur <span class="math notranslate nohighlight">\(e_i\)</span> lexikographisch kleiner ist als der Name des Studierenden der Klausur <span class="math notranslate nohighlight">\(e_j\)</span>.
<span class="math notranslate nohighlight">\(f_E\)</span> <strong>abstrahiert</strong> alle unwichtigen Eigenschaften der Elemente der gegebenen Liste <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>.</p>
<p>Wie das passende <span class="math notranslate nohighlight">\(f_E\)</span> definiert ist, wissen wir als Entwickler*innen des Suchalgorithmus nicht und müssen es auch nicht wissen.
Durch <span class="math notranslate nohighlight">\(f_E\)</span> haben wir das Problem in zwei Teilprobleme zerlegt:</p>
<ol class="simple">
<li><p>Die Definition des <strong>Komparators</strong> <span class="math notranslate nohighlight">\(f_E\)</span>, der zur Sortierung der Elemente passt und</p></li>
<li><p>die Suche unter der Annahme eines wohldefinierten <strong>Komparators</strong>.</p></li>
</ol>
<p>Wir lösen lediglich das zweite <strong>Teilproblem</strong>.
Um ersteres müssen sich die Anwender*innen unseres Suchalgorithmus kümmern.
Durch diese <strong>Abstraktion</strong> schaffen wir es einen Suchalgorithmus zu entwickeln, der <strong>jede beliebige sortierte Liste</strong> durchsuchen kann!</p>
<p>Wir haben aber noch ein Problem!
Nach was wollen wir denn eigentlich Suchen.
In der formalen Beschreibung vergleichen wir die Elemente in der Liste mit dem gesuchten Element.
Doch dieses gesuchte Element wollen wir ja gerade finden!
Wir kennen es nicht aber wir kennen etwas mit dem wir es identifizieren können.
Im Fall des Telefonbuchs, kennen wir den Nachnamen des Eintrags (Elements).
Der Nachname ist ein sogenannter Schlüssel, der ein Element eindeutig identifiziert.</p>
<p>Erneut können wir diesen Schlüssel heraus<strong>abstrahieren</strong> und erneut machen wir dies durch eine Funktion</p>
<div class="math notranslate nohighlight">
\[g: E \rightarrow \mathcal{K},\]</div>
<p>wobei <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> die Menge der Schlüssel ist.
Da wir demnach Schlüssel vergleichen ändern wir den <strong>Komperator</strong> <span class="math notranslate nohighlight">\(f_E\)</span> zu</p>
<div class="math notranslate nohighlight">
\[f_\mathcal{K}: \mathcal{K} \times \mathcal{K} \rightarrow \{-1,0,1 \}\]</div>
<div class="exercise admonition" id="binary-search-register-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.8 </span>(Binäre Suche mit Komperator)</p>
<div class="section" id="exercise-content">
<p>Transformieren Sie die formale Beschreibung (erneut) in eine <code class="docutils literal notranslate"><span class="pre">Python</span></code> Funktion <code class="docutils literal notranslate"><span class="pre">binary_search(key,</span> <span class="pre">mylist,</span> <span class="pre">f,</span> <span class="pre">g)</span></code>, welche Ihnen das Element mit dem Schlüssel <code class="docutils literal notranslate"><span class="pre">key</span></code> zurückgibt.</p>
<p><strong>Hinweis:</strong> In <code class="docutils literal notranslate"><span class="pre">Python</span></code> ist es möglich Funktionen einer anderen Funktion als Argument zu übergeben.</p>
</div>
</div>
<div class="admonition-ganzahlendivision-python admonition">
<p class="admonition-title">Ganzahlendivision (Python)</p>
<p>Teilen wir in <code class="docutils literal notranslate"><span class="pre">Python</span></code> zwei ganze Zahlen <code class="docutils literal notranslate"><span class="pre">/</span></code> so erhalten wir eine Fließkommazahl selbst wenn die Division eine Ganzzahl ergeben würde!</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="mi">4</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Python</span></code> bietet aber auch eine die Ganzzahlendivision <code class="docutils literal notranslate"><span class="pre">//</span></code> an bei der das Ergebnis immer eine Ganzzahl ist.
Es wird dabei stets auf die nächst liegende Ganzzahl <strong>abgerundet</strong>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="mi">3</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="mi">3</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="mi">4</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="mi">4</span><span class="o">//</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">mylist</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mylist</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
    <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">while</span> <span class="n">b</span><span class="o">-</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">mylist</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mylist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">f</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">mylist</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
<p>In unserer Lösung ist <code class="docutils literal notranslate"><span class="pre">g</span></code> als <em>Defaultwert</em> die Identität.
Das heißt, wenn die Anwender*innen kein <code class="docutils literal notranslate"><span class="pre">g</span></code> spezifizieren, gehen wir davon aus, dass</p>
<div class="math notranslate nohighlight">
\[\mathcal{K} = E\]</div>
<p>gilt.</p>
<div class="exercise admonition" id="binary-search-register-numbers-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.9 </span>(Binäre Suche von Zahlen mit Komperator)</p>
<div class="section" id="exercise-content">
<p>Definieren Sie einen passenden <strong>Komparator</strong> <code class="docutils literal notranslate"><span class="pre">cmp_numbers(number1,</span> <span class="pre">number2)</span></code> für eine Liste von ganzen Zahlen, d.h. <span class="math notranslate nohighlight">\(E = \mathbb{Z}\)</span> und testen Sie diesen und <code class="docutils literal notranslate"><span class="pre">binary_search</span></code>.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cmp_numbers</span><span class="p">(</span><span class="n">number1</span><span class="p">,</span> <span class="n">number2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">number1</span> <span class="o">&lt;</span> <span class="n">number2</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">number1</span> <span class="o">&gt;</span> <span class="n">number2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>

<span class="nb">print</span><span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">cmp_numbers</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">cmp_numbers</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="n">cmp_numbers</span><span class="p">))</span>
</pre></div>
</div>
<p>Lassen Sie uns noch das Telefonbuchbeispiel testen.
Folgender Code generiert Ihnen durch den Aufruf der Funktion <code class="docutils literal notranslate"><span class="pre">random_phone_book(n)</span></code> ein zufälliges Telefonbuch mit <code class="docutils literal notranslate"><span class="pre">100</span></code> Einträgen (unser Telefonbuch hat keine Seiten sondern nur Einträge).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">names</span>
<span class="kn">import</span> <span class="nn">functools</span> <span class="k">as</span> <span class="nn">func</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="k">def</span> <span class="nf">random_phone_number</span><span class="p">():</span>
    <span class="n">pre</span> <span class="o">=</span> <span class="s2">&quot;0&quot;</span><span class="o">+</span><span class="n">func</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">7</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pre</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">post</span>

<span class="k">def</span> <span class="nf">random_phone_book</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">telbook</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">names</span><span class="o">.</span><span class="n">get_last_name</span><span class="p">(),</span> <span class="s1">&#39;phone_number&#39;</span><span class="p">:</span> <span class="n">random_phone_number</span><span class="p">()}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">telbook</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">telbook</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">telbook</span>

<span class="n">telbook</span> <span class="o">=</span> <span class="n">random_phone_book</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>Sie müssen den Code nicht verstehen.
Für die Generierung eines zufälligen Namens bedienen wir uns eines Paketes <code class="docutils literal notranslate"><span class="pre">names</span></code>.
Und auch für die zufällige Telefonnummer setzten wir auf das <code class="docutils literal notranslate"><span class="pre">numpy</span></code> Paket.
Jeder Eintrag ist ein <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> der Form</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;phone_number&#39;</span><span class="p">:</span> <span class="n">telnr</span><span class="p">}</span>
</pre></div>
</div>
<div class="exercise admonition" id="binary-search-telbook-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.10 </span>(Binäre Suche)</p>
<div class="section" id="exercise-content">
<p>Generieren Sie sich ein zufälliges Telefonbuch und benutzten Sie die Funktion <code class="docutils literal notranslate"><span class="pre">binary_search(key,</span> <span class="pre">mylist,</span> <span class="pre">f,</span> <span class="pre">g)</span></code> um einen existierenden Namen <code class="docutils literal notranslate"><span class="pre">key</span></code> im Telefonbuch zu finden.
Sie müssen ein geeignetes <code class="docutils literal notranslate"><span class="pre">f</span></code> und <code class="docutils literal notranslate"><span class="pre">g</span></code> definieren.</p>
<p><strong>Tipp:</strong> Finden Sie heraus wie <code class="docutils literal notranslate"><span class="pre">Python</span></code> Zeichenketten vergleicht.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">66</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">telbook</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
<span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">entry</span> <span class="p">:</span> <span class="n">entry</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">cmp_strings</span><span class="p">(</span><span class="n">name1</span><span class="p">,</span> <span class="n">name2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name1</span> <span class="o">&lt;</span> <span class="n">name2</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="n">name1</span> <span class="o">&gt;</span> <span class="n">name2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="mi">0</span>
    

<span class="nb">print</span><span class="p">(</span><span class="n">binary_search</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">telbook</span><span class="p">,</span> <span class="n">cmp_strings</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition-zeichenkettenvergleich-python admonition">
<p class="admonition-title">Zeichenkettenvergleich (Python)</p>
<p>In <code class="docutils literal notranslate"><span class="pre">Python</span></code> werden Zeichenketten lexikographisch verglichen. Zum Beispiel ergibt</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;Abraham&quot;</span> <span class="o">&lt;</span> <span class="s2">&quot;Anna&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">True</span></code>.
Jedoch müssen sie auf die Klein- und Großschreibung achten.
So ergibt</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;abraham&quot;</span> <span class="o">&lt;</span> <span class="s2">&quot;Anna&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">False</span></code>.
Kleinbuchstaben sind also lexikographisch größer als Großbuchstaben.</p>
</div>
</div>
</div>
<div class="section" id="facher-und-markierungen">
<h2><span class="section-number">5.2. </span>Fächer und Markierungen<a class="headerlink" href="#facher-und-markierungen" title="Permalink to this headline">¶</a></h2>
<p>An Telefonbüchern finden sich häufig <strong>Markierungen</strong>, welche die Suche weiter beschleunigen.
Für jeden Buchstaben finden wir oft eine Markierung, sodass wir genau wissen wo wir Namen mit dem Anfangsbuchsten, z.B. <code class="docutils literal notranslate"><span class="pre">C</span></code>, finden.
Anstatt die <a class="reference internal" href="dive-bell.html#def-binary-search"><span class="std std-ref">binäre Suche</span></a> über alle Einträge durchzuführen, müssen wir lediglich alle Einträge, die mit <code class="docutils literal notranslate"><span class="pre">C</span></code> starten betrachten.</p>
<div class="exercise admonition" id="binary-search-supported-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.11 </span>(Unterstützte binäre Suche)</p>
<div class="section" id="exercise-content">
<p>Angenommen jeder Buchstabe kommt als Anfangsbuchstabe gleich häufig vor.
Wie viele Schritte (Intervallanpassungen) sparen Sie sich durch die Markierungen, wenn ihr Telefonbuch <span class="math notranslate nohighlight">\(20 000\)</span> Einträge enthält?</p>
</div>
</div>
<div class="solution dropdown admonition" id="binary-search-supported-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#binary-search-supported-exercise"><span>Exercise 5.11</span></a></p>
<div class="section" id="solution-content">
<p>Wir starten mit <span class="math notranslate nohighlight">\(20 000 / 26 \approx 769\)</span>.</p>
<div class="math notranslate nohighlight">
\[20 000 \cdot 2^{-5} &lt; 769 &lt; 20 000 \cdot 2^{-4}\]</div>
<p>Damit sparen wir uns <span class="math notranslate nohighlight">\(5\)</span> Schritte.</p>
</div>
</div>
<p>Eine weitere Variante Dinge zu Ordnen ist diese in unterschiedliche leicht identifizierbare <strong>Fächer</strong> zu packen.
Wir könnten zum Beispiel für jeden Anfangsbuchstaben ein Fach eröffnen und alle Seiten des Telefonbuchs in das jeweilige Fach packen.
Dafür müssten wir das Buch natürlich zerschneiden.</p>
<p>Diese zwei Varianten möchten wir uns ansehen</p>
<ol class="simple">
<li><p><strong>Fächer:</strong> Eine zweidimensionale Liste.</p></li>
<li><p><strong>Markierungen:</strong> Eine eindimensionale Liste unterstützt durch eine Liste aus Markierungen.</p></li>
</ol>
<p>Dazu werden wir zunächst Namen aus einer Datei einlesen und doppelte Einträge löschen.</p>
<div class="section" id="eine-csv-datei-lesen">
<h3><span class="section-number">5.2.1. </span>Eine CSV Datei lesen<a class="headerlink" href="#eine-csv-datei-lesen" title="Permalink to this headline">¶</a></h3>
<p>Lassen Sie uns diese Markierungen nutzten.
Wir werden dafür eine Liste der beliebtesten 1000 Mädchen- und Jungennamen von 1880 bis 2009 in den USA verwenden.
Die Datei ist eine CSV (Comma Seperated Value) Datei.
Eine solche Datei hat meist einen sogenannten <em>Header</em> (Kopfzeile) gefolgt von den jeweiligen Daten.
In unserem Fall sieht der Inhalt der Datei wie folgt aus.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;year&quot;</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">,</span><span class="s2">&quot;percent&quot;</span><span class="p">,</span><span class="s2">&quot;sex&quot;</span>
<span class="mi">1880</span><span class="p">,</span><span class="s2">&quot;John&quot;</span><span class="p">,</span><span class="mf">0.081541</span><span class="p">,</span><span class="s2">&quot;boy&quot;</span>
<span class="mi">1880</span><span class="p">,</span><span class="s2">&quot;William&quot;</span><span class="p">,</span><span class="mf">0.080511</span><span class="p">,</span><span class="s2">&quot;boy&quot;</span>
<span class="mi">1880</span><span class="p">,</span><span class="s2">&quot;James&quot;</span><span class="p">,</span><span class="mf">0.050057</span><span class="p">,</span><span class="s2">&quot;boy&quot;</span>
<span class="mi">1880</span><span class="p">,</span><span class="s2">&quot;Charles&quot;</span><span class="p">,</span><span class="mf">0.045167</span><span class="p">,</span><span class="s2">&quot;boy&quot;</span>
<span class="mi">1880</span><span class="p">,</span><span class="s2">&quot;George&quot;</span><span class="p">,</span><span class="mf">0.043292</span><span class="p">,</span><span class="s2">&quot;boy&quot;</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Wir möchten aus dieser Datei lediglich die Namen also die Spalte <code class="docutils literal notranslate"><span class="pre">name</span></code> extrahieren.
Später werden wir noch das Paket <code class="docutils literal notranslate"><span class="pre">Pandas</span></code> kennenlernen mit dem dies sehr viel einfacher geht.
Doch hier möchten wir selbst Hand anlegen.</p>
<p>Der folgende Code öffnet die Datei <code class="docutils literal notranslate"><span class="pre">baby-names.csv</span></code> und ließt diese, sodass nach der Ausführung <code class="docutils literal notranslate"><span class="pre">names</span></code> alle Namen von <code class="docutils literal notranslate"><span class="pre">baby-names.csv</span></code> enthält (auch doppelte Einträge).
<code class="docutils literal notranslate"><span class="pre">babynames</span></code> ist eine Sequenz von gelesenen Zeilen der CSV.
Durch <code class="docutils literal notranslate"><span class="pre">next(babynames)</span></code> überspringen wir die <em>Kopfzeile</em>.
Die <code class="docutils literal notranslate"><span class="pre">for</span></code> schleife iteriert über alle Zeilen.
Jede Zeile <code class="docutils literal notranslate"><span class="pre">row</span></code> beinhaltet für jede Spalte einen Eintrag.
<code class="docutils literal notranslate"><span class="pre">row[0]</span></code> ist das Jahr <code class="docutils literal notranslate"><span class="pre">year</span></code> und <code class="docutils literal notranslate"><span class="pre">row[0]</span></code> der Name <code class="docutils literal notranslate"><span class="pre">name</span></code>, den wir extrahieren möchten.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">reader</span>

<span class="k">def</span> <span class="nf">read_babynames</span><span class="p">():</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;baby-names.csv&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">babynames</span> <span class="o">=</span> <span class="n">reader</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">babynames</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">babynames</span><span class="p">:</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">names</span>

<span class="n">names</span> <span class="o">=</span> <span class="n">read_babynames</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="zahlen-von-doppelten-eintragen">
<h3><span class="section-number">5.2.2. </span>Zählen von doppelten Einträgen<a class="headerlink" href="#zahlen-von-doppelten-eintragen" title="Permalink to this headline">¶</a></h3>
<div class="exercise admonition" id="count-duplicates-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.12 </span>(Zählen doppelter Einträge)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie eine Funktion <code class="docutils literal notranslate"><span class="pre">count(name,</span> <span class="pre">names)</span></code>, welche die Anzahl der Einträge in <code class="docutils literal notranslate"><span class="pre">names</span></code> die gleich <code class="docutils literal notranslate"><span class="pre">name</span></code> sind zurückgibt.
Zählen Sie die Vorkommen von <code class="docutils literal notranslate"><span class="pre">John</span></code>.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">names</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">entry</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">+=</span><span class="mi">1</span> 
    <span class="k">return</span> <span class="n">count</span>

<span class="n">count</span><span class="p">(</span><span class="s2">&quot;John&quot;</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
</pre></div>
</div>
<p>Wir möchten nun die Anzahl aller Namen in <code class="docutils literal notranslate"><span class="pre">names</span></code> zählen.
Diese Anzahl sagt uns wie oft ein Name von 1880 bis 2008 in den Top 1000 der beliebtesten Namen in den USA war.
Dazu legen wir ein <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> an wobei der Schlüssel <code class="docutils literal notranslate"><span class="pre">key</span></code> des <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionarys</span></a> ein Name ist und dessen Wert <code class="docutils literal notranslate"><span class="pre">value</span></code> wie oft dieser Name vorkommt.
Zum Beispiel:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">countings</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;John&#39;</span><span class="p">:</span> <span class="mi">234</span><span class="p">,</span> <span class="s1">&#39;Anna&#39;</span><span class="p">:</span> <span class="mi">201</span><span class="p">,</span> <span class="o">...</span><span class="p">}</span>
</pre></div>
</div>
<p>Wir haben die folgenden beiden Funktionen entwickelt:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_all</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="n">countings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">countings</span><span class="p">:</span>
            <span class="n">countings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
</pre></div>
</div>
<p>und</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">count_all</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="n">countings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">countings</span><span class="p">:</span>
            <span class="n">countings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">countings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="exercise admonition" id="count-all-duplicates-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.13 </span>(Zählen aller Einträge)</p>
<div class="section" id="exercise-content">
<p>Welche der beiden Varianten ist die bessere? Begründen Sie Ihre Antwort.</p>
</div>
</div>
<div class="solution dropdown admonition" id="count-all-duplicates-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#count-all-duplicates-exercise"><span>Exercise 5.13</span></a></p>
<div class="section" id="solution-content">
<p>Die zweite Variante ist die bessere, da sie das gleiche Ergebnis in weniger Schritten erzeugt.
<code class="docutils literal notranslate"><span class="pre">count</span></code> iteriert durch die gesamte Liste <code class="docutils literal notranslate"><span class="pre">names</span></code> deshalb benötigen wir in der ersten Variante <span class="math notranslate nohighlight">\(n \cdot n\)</span> Schritte und in der zweiten Variante nur <span class="math notranslate nohighlight">\(n\)</span> Schritte, wobei <span class="math notranslate nohighlight">\(n\)</span> die Länge der Liste <code class="docutils literal notranslate"><span class="pre">names</span></code> ist.</p>
</div>
</div>
<p>Dieses Beispiel zeigt, dass es nicht immer von Vorteil ist, ein größeres Problem (<code class="docutils literal notranslate"><span class="pre">count_all</span></code>) durch Teilprobleme (<code class="docutils literal notranslate"><span class="pre">count</span></code>) zu lösen.</p>
<p>Interessanterweise haben wir durch unser Zählen auch gleich alle doppelten Einträge gelöscht, denn wenn wir nun alle Schlüssel des <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> in eine Liste packen, so beinhaltet diese keine doppelten Einträge mehr.</p>
<div class="exercise admonition" id="unique-entries-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.14 </span>(Einzigartige Einträge)</p>
<div class="section" id="exercise-content">
<p>Sammeln Sie nun alle Schlüssel ein und packen Sie diese in eine Liste.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">unique_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">countings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</pre></div>
</div>
<p>In <a class="reference internal" href="../05/2-sort-cards-with-python.html#sort-cards-with-python"><span class="std std-ref">Karten sortieren</span></a> haben wir selbst einen Sortieralgorithmus entworfen.
Selbstverständlich hat <code class="docutils literal notranslate"><span class="pre">Python</span></code> bereits einen solchen Algorithmus im Angebot.
Diesen haben wir oben beim Generieren des zufälligen Telefonbuchs verwendet.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>sorted?
</pre></div>
</div>
<p>bzw.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="nb">sorted</span><span class="p">)</span>
</pre></div>
</div>
<p>Liefert Ihnen Hinweise darüber was die Funktion macht und wie sie zu benutzten ist.</p>
<div class="exercise admonition" id="unique-entries-sort-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.15 </span>(Einzigartige Einträge sortieren)</p>
<div class="section" id="exercise-content">
<p>Verwedenden Sie <code class="docutils literal notranslate"><span class="pre">sorted</span></code> um <code class="docutils literal notranslate"><span class="pre">unique_names</span></code></p>
<ol class="simple">
<li><p>lexikographisch</p></li>
<li><p>nach der Anzahl der Einträge in <code class="docutils literal notranslate"><span class="pre">names</span></code> (meist vorkommende Name ganz vorne in der Liste)</p></li>
</ol>
<p>zu sortieren</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">unique_names_lex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unique_names</span><span class="p">)</span>
<span class="n">unique_names_count</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">unique_names</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">entry</span> <span class="p">:</span> <span class="n">countings</span><span class="p">[</span><span class="n">entry</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ordnung-durch-facher">
<h3><span class="section-number">5.2.3. </span>Ordnung durch Fächer<a class="headerlink" href="#ordnung-durch-facher" title="Permalink to this headline">¶</a></h3>
<p>Mit <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> haben wir eine lexikographisch sortierte Liste an beliebten Babynamen in den USA.
Wäre es nicht praktisch sich die Namen, welche mit einem bestimmten Buchstaben beginnen aus der Lister herauszuziehen?
Dies vereinfacht die Suche nach einem bestimmten Namen.
Lassen Sie uns überdenken wie und warum wir Menschen Dinge in <strong>Fächern</strong> (engl. <strong>Buckets</strong>) ordnen.</p>
<p>Wie ordnen wir Menschen ganz alltägliche Dinge?
Zum Beispiel in der Küche oder im Schlafzimmer?
Gläser befinden sich in einem bestimmten Schrank, Teller in einem anderen.
Das Besteck stecken wir in eine Schublade und diese ist oft so aufgeteilt, dass Messer, Löffel und Gabeln sich in je einem separierten Teil befinden.
Hosen trennen wir von anderen Klamotten.
Die Unterwäsche befindet sich an einer ganz bestimmten Stelle im Kleiderschrank.
In einem Ordner sammeln wir Steuerunterlagen in dem anderen Arbeitsverträge oder Zeugnisse.</p>
<p>Warum machen wir das?
Nun damit wir bestimmte Dinge schneller finden.
Anstatt den gesamten Schrank nach einer Hose zu durchsuchen, müssen wir nur einen kleinen Teil durchwühlen.
Diese Ordnung dient natürlich auch der Übersicht.
So sehen wir sehr schnell, wie viele Hosen wir überhaupt besitzten und ob es Zeit wird sich mal wieder eine neue zu besorgen.</p>
<p>Die wesentliche Eigenschaft, die wir diesen Beispielen entziehen können ist, dass wir Dinge in <strong>Fächern</strong> ordnen.
Diese <strong>Fächer</strong> können wir eindeutig und schnell identifizieren bzw. auf diese schnell zugreifen.
So wissen wir in welcher Schublade sich das Besteck befindet und in welchem Unterabteil der Schublade wir zur Gabel greifen.
<strong>Fächer</strong> können sortiert sein, z.B. sind unsere Hemden möglicherweise in einer ganz bestimmten Reihenfolge aufgehängt.
Sie können aber auch unsortiert sein, z.B. sind alle Gabeln durcheinander in einem Schubladenabteil.
Befindet sich eine bestimmte Art von Dingen in einem <strong>Fach</strong> so können wir uns einen Überblick über diese eine Art verschaffen.</p>
<p>Es ist kein Zufall, dass wir Menschen Dinge in <strong>Fächern</strong> ordnen.
Wir passen uns auch im Alltag den algorithmischen Strukturen an, die uns durch die Natur gegeben sind.
Besonders bei den simpleren Datenstrukturen wird klar, dass es nicht die Informatiker*innen waren, die diese Strukturen erfunden haben.
Sie haben diese lediglich aus der Natur <strong>abstrahiert</strong>, in ein imaginäres Objekt umgewandelt und schließlich wieder als reales Objekt auf den Computer gebracht.</p>
<p>In der <strong>abstrakten Welt</strong> modellieren wir mehrere <strong>Fächer</strong> meist durch eine einfache Liste.
Jeder Listeneintrag <strong>repräsentiert</strong> ein <strong>Fach</strong> was wiederum eine Liste aber auch ein anderer <a class="reference internal" href="../10/5-data-types.html#def-collection"><span class="std std-ref">Sammlung (Collection)</span></a> sein kann, siehe untere
<a class="reference internal" href="#fig-buckets"><span class="std std-numref">Abbildung 5.3</span></a>.</p>
<div class="figure align-default" id="fig-buckets">
<a class="reference internal image-reference" href="../../_images/bucket.png"><img alt="../../_images/bucket.png" src="../../_images/bucket.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.3 </span><span class="caption-text">Fächer als Liste von Listen</span><a class="headerlink" href="#fig-buckets" title="Permalink to this image">¶</a></p>
</div>
<p>Da wir eine Liste zur Modellierung verwenden müssen wir anhand des Listenindex das gewünschte Fach identifizieren können.
In unserem Beispiel brauchen wir eine Funktion <code class="docutils literal notranslate"><span class="pre">index_of</span></code> die uns für einen Buchstaben den korrekten Index gibt.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">index_of</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Wir machen aus <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> eine zweidimensionale Liste <code class="docutils literal notranslate"><span class="pre">names_by_letter</span></code>, sodass</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">names_by_letter[0]</span></code> alle Namen die mit <code class="docutils literal notranslate"><span class="pre">A</span></code> beginnen enthält, und</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">names_by_letter[1]</span></code> alle Namen die mit <code class="docutils literal notranslate"><span class="pre">B</span></code> beginnen enthält, und</p></li>
<li><p>…</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">names_by_letter[25]</span></code> alle Namen die mit <code class="docutils literal notranslate"><span class="pre">Z</span></code> beginnen enthält.</p></li>
</ul>
<div class="figure align-default" id="fig-babynames-buckets">
<a class="reference internal image-reference" href="../../_images/babynames.png"><img alt="../../_images/babynames.png" src="../../_images/babynames.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.4 </span><span class="caption-text">Babynamen in Fächern</span><a class="headerlink" href="#fig-babynames-buckets" title="Permalink to this image">¶</a></p>
</div>
<div class="exercise admonition" id="babynames-buckets-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.16 </span>(Babynamen in Fächern)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie eine Funktion <code class="docutils literal notranslate"><span class="pre">to_lex_buckets(unique_names_lex)</span></code> welche Ihnen die <a class="reference internal" href="../10/5-data-types.html#def-collection"><span class="std std-ref">Sammlung</span></a> aus <a class="reference internal" href="#fig-babynames-buckets"><span class="std std-numref">Abbildung 5.4</span></a> erzeugt.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">to_lex_buckets</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">):</span>
    <span class="n">names_by_letter</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="n">letter</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>

    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">unique_names_lex</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">letter</span><span class="p">:</span>
            <span class="n">letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">names_by_letter</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>     
        <span class="n">names_by_letter</span><span class="p">[</span><span class="n">index_of</span><span class="p">(</span><span class="n">letter</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">names_by_letter</span>

<span class="n">names_by_letter</span> <span class="o">=</span> <span class="n">to_lex_buckets</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">)</span>
</pre></div>
</div>
<p>Beachten Sie, dass wir statt einer <code class="docutils literal notranslate"><span class="pre">if</span></code>-Kondition, eine <code class="docutils literal notranslate"><span class="pre">while</span></code>-Schleife verwenden.
Warum?
Nun es könnte sein, dass es einen Buchstaben gibt, für den gar kein Name in der Liste ist.</p>
<p>Um mit unserer neuen Datenstruktur zurecht zu kommen, können wir uns weitere Hilfsfunktionen basteln.
Zum Beispiel wäre es praktisch auf ein bestimmtes <strong>Fach</strong> nicht über den Index <span class="math notranslate nohighlight">\(0,1,\ldots, 25\)</span> sondern über den entsprechenden Buchstaben <code class="docutils literal notranslate"><span class="pre">A</span></code>,<code class="docutils literal notranslate"><span class="pre">B</span></code>,…,<code class="docutils literal notranslate"><span class="pre">Z</span></code> zuzugreifen.</p>
<div class="exercise admonition" id="access-with-buckets">
<p class="admonition-title"><span class="caption-number">Exercise 5.17 </span>(Zugriff eines Fachs)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie eine Funktion <code class="docutils literal notranslate"><span class="pre">get_names(char,</span> <span class="pre">names_by_letter)</span></code>, die Ihnen für einen Buchstaben <code class="docutils literal notranslate"><span class="pre">char</span></code> die Liste mit allen Babynamen, welche mit <code class="docutils literal notranslate"><span class="pre">char</span></code> beginnen (der soeben erzeugen Datenstruktur <code class="docutils literal notranslate"><span class="pre">names_by_letter</span></code>) zurückliefert.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_names</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">names_by_letter</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">names_by_letter</span><span class="p">[</span><span class="n">index_of</span><span class="p">(</span><span class="n">char</span><span class="p">)]</span>

<span class="n">get_names</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">names_by_letter</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="ordnung-durch-markierungen">
<h3><span class="section-number">5.2.4. </span>Ordnung durch Markierungen<a class="headerlink" href="#ordnung-durch-markierungen" title="Permalink to this headline">¶</a></h3>
<p>Wenn wir ein Telefonbuch genauer betrachten werden wir feststellen, dass es mit gut sichtbaren <strong>Markierungen</strong> versehen ist.
Zum Beispiel finden wir häufig für jeden Anfangsbuchstaben eine solche Markierung.
Wir können diese <strong>Markierungen</strong> auch als <strong>Fächer</strong> interpretieren denn mithilfe von zwei aufeinanderfolgenden <strong>Markierungen</strong> beschreiben wir ein <strong>Fach</strong>.
Nehmen wir zum Beispiel die Markierung für <code class="docutils literal notranslate"><span class="pre">C</span></code> und <code class="docutils literal notranslate"><span class="pre">D</span></code> so können wir das <strong>Fach</strong> <code class="docutils literal notranslate"><span class="pre">C</span></code> bzw. 2 identifizieren.</p>
<p>Diese Gemeinsamkeit ist ersichtlich doch worin unterscheiden sich <strong>Markierungen</strong> von <strong>Fächern</strong>?
Anders gefragt: Worin unterscheidet sich Ihr Kleiderschrank von einem Telefonbuch im wesentlichen?</p>
<div class="exercise admonition" id="buckets-vs-marks-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.18 </span>(Kleiderschrank und Telefonbücher)</p>
<div class="section" id="exercise-content">
<p>Welche wesentliche Eigenschaft unterscheidet einen Kleiderschrank (<strong>Fächer</strong>) von einem Telefonbuch (<strong>Markierungen</strong>)?
Es geht uns um eine Eigenschaft, die sich auf die Implementierung auswirkt.</p>
</div>
</div>
<div class="solution dropdown admonition" id="buckets-vs-marks-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#buckets-vs-marks-exercise"><span>Exercise 5.18</span></a></p>
<div class="section" id="solution-content">
<p>Einen Kleiderschrank befüllen und leeren wir, er ist <strong>veränderlich</strong> (engl. <strong>mutable</strong>)!
Wir legen neue Kleider hinein und holen Kleider heraus.
Ein Telefonbuch ist <strong>unveränderlich</strong> (engl. <strong>immutable</strong>).</p>
</div>
</div>
<p>Wenn Sie sich unsere Implementierung der <strong>Fächer</strong> ansehen, wird klar, dass wir sehr einfach neue Namen hinzufügen können.
Falls uns doppelte Elemente und die Sortierung innerhalb eines <strong>Fachs</strong> gleichgültig sind, reicht es das Element hinten anzuhängen.
Andernfalls müssen wir die richtige Stelle identifizieren an der wir ein neues Element einfügen können.
Wir müssen jedoch so oder so nichts an der Anordnung der <strong>Fächer</strong> ändern!</p>
<p>Wie realisieren wir <strong>Markierungen</strong>?
Eine <strong>Markierung</strong> zeigt auf eine bestimmte Seite im Telefonbuch in unserem Beispiel mit den Babynamen zeigt sie auf einen bestimmten Index der Liste aus Babynamen.
Wir verwenden weiterhin <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> fügen aber eine weitere unterstützende Liste <code class="docutils literal notranslate"><span class="pre">marks</span></code> hinzu sodass</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">marks[0]</span></code> auf den kleinsten Index zeigt der einen Namen der mit einem <code class="docutils literal notranslate"><span class="pre">A</span></code> startet enthält,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">marks[1]</span></code> auf den kleinsten Index zeigt der einen Namen der mit einem <code class="docutils literal notranslate"><span class="pre">B</span></code> startet enthält,</p></li>
<li><p>…</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">marks[25]</span></code> auf den kleinsten Index zeigt der einen Namen der mit einem <code class="docutils literal notranslate"><span class="pre">Z</span></code> startet enthält.</p></li>
</ul>
<div class="figure align-default" id="fig-babynames-marks">
<a class="reference internal image-reference" href="../../_images/marks.png"><img alt="../../_images/marks.png" src="../../_images/marks.png" style="width: 250px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.5 </span><span class="caption-text">Babynamen (rechts) mit Markierungen (links)</span><a class="headerlink" href="#fig-babynames-marks" title="Permalink to this image">¶</a></p>
</div>
<div class="exercise admonition" id="babynames-marks-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.19 </span>(Markierungen erzeugen)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie eine Funktion <code class="docutils literal notranslate"><span class="pre">generate_marks(names_by_letter)</span></code> die Ihnen Markierungen <code class="docutils literal notranslate"><span class="pre">marks</span></code> aus <a class="reference internal" href="#fig-babynames-marks"><span class="std std-numref">Abbildung 5.5</span></a> erzeugt.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">generate_marks</span><span class="p">(</span><span class="n">names_by_letter</span><span class="p">):</span>
    <span class="n">marks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">letter</span> <span class="o">=</span> <span class="s1">&#39;A&#39;</span>
    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">unique_names_lex</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">letter</span><span class="p">:</span>
            <span class="n">letter</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">marks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">marks</span>

<span class="n">marks</span> <span class="o">=</span> <span class="n">generate_marks</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">)</span>
<span class="n">unique_names_lex</span><span class="p">[</span><span class="n">marks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>Wir können nun sehr einfach durch alle Namen iterieren die mit einem <code class="docutils literal notranslate"><span class="pre">C</span></code> starten:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">marks</span> <span class="o">=</span> <span class="n">generate_marks</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">)</span>

<span class="n">mark_index</span> <span class="o">=</span> <span class="n">index_of</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">marks</span><span class="p">[</span><span class="n">mark_index</span><span class="p">],</span> <span class="n">marks</span><span class="p">[</span><span class="n">mark_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
<p>Oder wir können uns eine Teilliste kopieren die nur Namen beinhaltet die mit <code class="docutils literal notranslate"><span class="pre">D</span></code> starten:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">mark_index</span> <span class="o">=</span> <span class="n">index_of</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>
<span class="n">unique_names_lex</span><span class="p">[</span><span class="n">marks</span><span class="p">[</span><span class="n">mark_index</span><span class="p">]:</span><span class="n">marks</span><span class="p">[</span><span class="n">mark_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>Wir hatten festgehalten, dass sich ein Telefonbuch mit <strong>Markierungen</strong> nicht verändert.
Welches Problem tritt auf wenn wir Elemente in die Liste der sortierten Babynamen einfügen?</p>
<div class="exercise admonition" id="babynames-marks-insert-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.20 </span>(Elemente einfügen und Markierungen anpassen)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie folgende Hilfsfunktionen:</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">add_name(name,</span> <span class="pre">unique_names_lex,</span> <span class="pre">marks)</span></code>: Fügt einen Namen <code class="docutils literal notranslate"><span class="pre">name</span></code> <strong>an die korrekte Stelle</strong> in <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> ein.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">remove_name_(name,</span> <span class="pre">unique_names_lex,</span> <span class="pre">marks)</span></code>: Löscht einen Namen <code class="docutils literal notranslate"><span class="pre">name</span></code> (falls vorhanden).</p></li>
</ol>
<p>Beide Funktionen passen <code class="docutils literal notranslate"><span class="pre">marks</span></code> entsprechend an!
Die Sortierung soll erhalten bleiben!
Eventuell macht es Sinn eine weitere Hilfsfunktion <code class="docutils literal notranslate"><span class="pre">index_of_element(name,</span> <span class="pre">unique_names_lex,</span> <span class="pre">marks)</span></code> zu schreiben, welche Ihnen den Index <code class="docutils literal notranslate"><span class="pre">i</span></code> des Namen <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> zurückliefert.</p>
<p><strong>Tipp:</strong> Verwenden Sie die Methoden der <code class="docutils literal notranslate"><span class="pre">Python</span></code>-Liste <a class="reference external" href="https://www.w3schools.com/python/ref_list_append.asp">append</a>, <a class="reference external" href="https://www.w3schools.com/python/ref_list_insert.asp">insert</a> und <a class="reference external" href="https://www.w3schools.com/python/ref_list_pop.asp">pop</a>.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">index_of_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">&lt;</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">return</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">name</span> <span class="o">&gt;</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">)</span>
    
    <span class="n">letter</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mark_index</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">marks</span><span class="p">[</span><span class="n">mark_index</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">marks</span><span class="p">[</span><span class="n">mark_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
            
<span class="k">def</span> <span class="nf">add_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">):</span>
    <span class="c1"># 1. compute index</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">)</span>

    <span class="c1"># 2. insert if name is not contained</span>
    <span class="k">if</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">unique_names_lex</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
       
        <span class="c1"># 3. adapt marks</span>
        <span class="n">letter</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mark_index</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mark_index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">marks</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">marks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
    
<span class="k">def</span> <span class="nf">remove_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">):</span>
    <span class="c1"># 1. compute index</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index_of_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">)</span>
    
    <span class="c1"># 2. delete if name is contained</span>
    <span class="k">if</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">unique_names_lex</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        
        <span class="c1"># 3. adapt marks</span>
        <span class="n">letter</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mark_index</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">letter</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mark_index</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">marks</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">marks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>
        
<span class="nb">print</span><span class="p">(</span><span class="n">index_of_element</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">[</span><span class="mi">88</span><span class="p">],</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">88</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">index_of_element</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">[</span><span class="mi">2388</span><span class="p">],</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2388</span><span class="p">)</span>
<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Mustermann&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">))</span>
<span class="n">add_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">))</span>
<span class="n">remove_element</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">marks</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">))</span>
</pre></div>
</div>
<p>Jedesmal wenn wir die Liste mit sortierten Babynamen ändern, müssen wir auch <code class="docutils literal notranslate"><span class="pre">marks</span></code> anpassen.
Je nachdem wie viele <strong>Markierungen</strong> wir haben, kann dies viel Zeit kosten.</p>
</div>
</div>
<div class="section" id="hashing-und-das-dictionary">
<span id="sec-hashing"></span><h2><span class="section-number">5.3. </span>Hashing und das Dictionary<a class="headerlink" href="#hashing-und-das-dictionary" title="Permalink to this headline">¶</a></h2>
<p>In <a class="reference internal" href="memory.html#sec-memory"><span class="std std-ref">Speicher - alles ist eine Liste</span></a> haben wir uns angesehen wie Listen im <a class="reference internal" href="../06/4-information-flow.html#def-main-memory"><span class="std std-ref">Arbeitsspeicher</span></a> realisiert werden.
Erinnern Sie sich!
Im Speicher liegen nur Zahlen und aus diesen Zahlen haben wir uns den Datentyp Liste gebastelt.
Was wir nicht beschrieben haben ist wie die zweite wesentliche Datenstruktur, das <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> im Speicher realisiert ist.
Wie der Titel dieser Aufgabe betont, ist alles eine Liste.
Der <a class="reference internal" href="../06/4-information-flow.html#def-main-memory"><span class="std std-ref">Arbeitsspeicher</span></a> ist eine Liste durch den wir <code class="docutils literal notranslate"><span class="pre">Python</span></code>-Listen erhalten und die Basis des <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> ist Liste die im Speicher liegt.</p>
<p>In diesem Abschnitt werden wir uns gemeinsam erarbeiten wie wir von einer Liste zu einem <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> gelangen.
Der Schlüssel hierfür sind die sogenannten Hashingverfahren.</p>
<p>Datenstrukturen die das <strong>Hashing</strong> verwenden versuchen die Speicheradresse (siehe <a class="reference internal" href="memory.html#sec-memory"><span class="std std-ref">Speicher - alles ist eine Liste</span></a>) bzw. den Index eines Elements in einer Liste <em>direkt</em> durch einfache arithmetische Operationen aus einem Schlüssel <code class="docutils literal notranslate"><span class="pre">key</span></code> des Elements zu berechnen.
Genau genommen verwendet unsere obige Fächer-Datenstruktur Hashing, denn wir berechnen anhand des Anfangsbuchstaben eines Elements (d.h. seinem <code class="docutils literal notranslate"><span class="pre">key</span></code>) einen Index.</p>
<p>Mit “versuchen” meinen wir, dass zwei unterschiedliche Elemente aber auch zwei verschiedene Schlüssel den gleichen Index ergeben können.
Dies bezeichnen wir als <strong>Kollision</strong>.
Diese Kollisionen müssen wir irgendwie auflösen.</p>
<div class="admonition-universum-schlussel-liste-und-hashfunktion admonition">
<p class="admonition-title">Universum, Schlüssel, Liste und Hashfunktion</p>
<p>Für die weitere Diskussion benötigen wir folgende Definitionen:</p>
<ul class="simple">
<li><p>Ein <em>Universum</em> <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> an möglichen Schlüsseln, zum Beispiel <span class="math notranslate nohighlight">\(\mathcal{U} \subseteq \mathbb{N}_0\)</span>,</p></li>
<li><p>Eine Menge an <em>Schlüsseln</em> <span class="math notranslate nohighlight">\(\mathcal{K} \subseteq \mathcal{U}\)</span>,</p></li>
<li><p>Eine Liste <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> mit <span class="math notranslate nohighlight">\(|\mathcal{L}| = n\)</span>, oft auch <em>Hashtabelle</em> genannt,</p></li>
<li><p>und eine <em>Hashfunktion</em> <span class="math notranslate nohighlight">\(h : \mathcal{U} \rightarrow \{0, \ldots, n-1\}\)</span></p></li>
</ul>
</div>
<p>In unserer Fächer-Datenstruktur, lösen wir es indem wir alle Elemente mit dem gleichen Index in eine zweite Liste packen.
Ein solches Verfahren heißt <em>offenes Hashing mit geschlossener Adressierung</em>.</p>
<div class="figure align-default" id="fig-open-hashing">
<a class="reference internal image-reference" href="../../_images/open-hashing.png"><img alt="../../_images/open-hashing.png" src="../../_images/open-hashing.png" style="width: 530px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.6 </span><span class="caption-text">Offenes Hashing realisiert durch Fächer.</span><a class="headerlink" href="#fig-open-hashing" title="Permalink to this image">¶</a></p>
</div>
<div class="exercise admonition" id="name-register-open-hashing-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.21 </span>(Offenes Hashing)</p>
<div class="section" id="exercise-content">
<p>Benennen Sie <span class="math notranslate nohighlight">\(\mathcal{U}\)</span>, <span class="math notranslate nohighlight">\(\mathcal{K}\)</span>, <span class="math notranslate nohighlight">\(n\)</span> unserer Fächer-Datenstruktur und beschreiben Sie <span class="math notranslate nohighlight">\(h\)</span>.</p>
</div>
</div>
<div class="solution dropdown admonition" id="name-register-open-hashing-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#name-register-open-hashing-exercise"><span>Exercise 5.21</span></a></p>
<div class="section" id="solution-content">
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathcal{U}\)</span> = alle möglichen Zeichenketten</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathcal{K}\)</span> = alle Zeichenketten in <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code></p></li>
<li><p><span class="math notranslate nohighlight">\(n = 26\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(h\)</span>: Entspricht <code class="docutils literal notranslate"><span class="pre">index_of(name)</span></code> und berechnet aus dem ersten Zeichen einer Zeichenkette die Stelle des Buchstabens im Alphabet (beginnend bei null).</p></li>
</ul>
</div>
</div>
<p>Eine weitere Möglichkeit eine <strong>Kollision</strong> aufzulösen ist es nur eine große Liste zu verwenden.
Tritt eine Kollision auf, so wird nach einem anderen freien Platz gesucht.
Für diese Technik muss <span class="math notranslate nohighlight">\(\mathcal{L}\)</span> deutlich größer sein.
Sobald die Liste droht voll zu laufen muss sie vergößert werden.
Ein solches Verfahren heißt <em>geschlossenes Hashing mit offener Adressierung</em>.
In <a class="reference internal" href="#fig-closed-hashing"><span class="std std-numref">Abbildung 5.7</span></a> ist dieses mit einer der einfachsten Kollisionsauflösungen skizziert: Falls ein Platz belegt ist suchen wir aufsteigend nach dem nächst liegenden freien Platz.</p>
<div class="figure align-default" id="fig-closed-hashing">
<a class="reference internal image-reference" href="../../_images/closed-hashing.png"><img alt="../../_images/closed-hashing.png" src="../../_images/closed-hashing.png" style="width: 430px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.7 </span><span class="caption-text">Geschlossenes Hashing</span><a class="headerlink" href="#fig-closed-hashing" title="Permalink to this image">¶</a></p>
</div>
<p>Egal welche Technik verwendet wird, eine solche <a class="reference internal" href="../10/5-data-types.html#def-collection"><span class="std std-ref">Sammlung</span></a> enthält keine doppelten Schlüssel.
Wir nennen eine solche <a class="reference internal" href="../10/5-data-types.html#def-collection"><span class="std std-ref">Sammlung</span></a> auch <strong>Hashtable</strong>.
Ziel ist es in <strong>konstant vielen Schritten</strong> auf ein beliebiges Element einer solchen <a class="reference internal" href="../10/5-data-types.html#def-collection"><span class="std std-ref">Sammlung</span></a></p>
<ul class="simple">
<li><p>zuzugreifen <code class="docutils literal notranslate"><span class="pre">search</span></code>,</p></li>
<li><p>ein Element einzufügen <code class="docutils literal notranslate"><span class="pre">insert</span></code>,</p></li>
<li><p>oder zu löschen <code class="docutils literal notranslate"><span class="pre">delete</span></code>.</p></li>
</ul>
<div class="section" id="geschlossenes-hashing">
<h3><span class="section-number">5.3.1. </span>Geschlossenes Hashing<a class="headerlink" href="#geschlossenes-hashing" title="Permalink to this headline">¶</a></h3>
<p>Lassen Sie uns aus anstatt des <em>offenen Hashings</em> das <em>geschlossene Hashing</em> aus <a class="reference internal" href="#fig-closed-hashing"><span class="std std-numref">Abbildung 5.7</span></a> verwenden.
Wir möchten dabei zunächst unsere bereits bekannte <em>Hashfunktion</em> <code class="docutils literal notranslate"><span class="pre">index_of(name)</span></code> einsetzten.
Außerdem gehen wir zunächst davon aus, dass die Menge der Schlüssel erneut unsere Babynamen sind.</p>
<div class="exercise admonition" id="name-register-open-hashing-index-search-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.22 </span>(Indexsuche)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie eine Funktion <code class="docutils literal notranslate"><span class="pre">search_index(name,</span> <span class="pre">hashtable)</span></code>, welche Ihnen den index des Namens <code class="docutils literal notranslate"><span class="pre">name</span></code> der Liste <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> anhand der Hashfunktion <code class="docutils literal notranslate"><span class="pre">index_of(element)</span></code> liefert.
Gehen Sie davon aus, dass ein Platz in der Liste frei ist wenn dieser gleich <code class="docutils literal notranslate"><span class="pre">None</span></code> ist.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index_of</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span>
    
    <span class="c1"># there is no free place left</span>
    <span class="k">return</span> <span class="kc">None</span>
</pre></div>
</div>
<p>Wir starten die Suche bei Index <code class="docutils literal notranslate"><span class="pre">index_of(key)</span> <span class="pre">%</span> <span class="pre">len(hashtable)</span></code> um sicher zu gehen, dass der Index nicht außerhalb der Liste liegt.
Dann durchlaufen wir die Liste zyklisch bis wir einen freien Platz finden oder aber festellen, dass die Liste voll ist.</p>
<div class="exercise admonition" id="name-register-open-hashing-management-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.23 </span>(Hashtableverwaltung)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie mithilfe <code class="docutils literal notranslate"><span class="pre">search_index(name,</span> <span class="pre">hashtable)</span></code> nun folgende Funktionen:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">contains(name,</span> <span class="pre">hashtable)</span></code>: Liefert <code class="docutils literal notranslate"><span class="pre">True</span></code> genau dann wenn <code class="docutils literal notranslate"><span class="pre">name</span></code> sich in der Liste <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> befindet.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_value(name,</span> <span class="pre">hashtable)</span></code>: Liefert <code class="docutils literal notranslate"><span class="pre">name</span></code> zurück falls es in <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> enthalten ist, sonst <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">insert(name,</span> <span class="pre">hashtable)</span></code>: Fügt <code class="docutils literal notranslate"><span class="pre">name</span></code> in <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> falls es noch nicht in <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> enthalten ist und gibt <code class="docutils literal notranslate"><span class="pre">True</span></code> zurück genau dann wenn <code class="docutils literal notranslate"><span class="pre">name</span></code> eingefügt wurde.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new_hash_table(names)</span></code>: Erzeugt unter der Verwendung der Funktion <code class="docutils literal notranslate"><span class="pre">insert</span></code> eine neue Liste <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> welche alle Namen in der Liste <code class="docutils literal notranslate"><span class="pre">names</span></code> enthält.</p></li>
</ul>
<p>Testen Sie Ihre Funktionen mithilfe einer kleinen Liste an Namen, z.B.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Berta&#39;</span><span class="p">,</span> <span class="s1">&#39;Hans&#39;</span><span class="p">,</span> <span class="s1">&#39;Thomas&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p><strong>Hinweis:</strong> Überlegen Sie sich was Sie machen wenn die Liste voll gelaufen ist!</p>
</div>
</div>
<p>Falls <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> voll ist fügen wir den einzufügenden Namen hinten an.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">index_of</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">):</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">index_of</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span>
        
    <span class="c1"># there is no free place left</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span>

<span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kc">None</span>

<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">):</span>
        <span class="n">hashtable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">new_hash_table</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
    <span class="n">hashtable</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hashtable</span>
</pre></div>
</div>
<p>Lassen Sie uns die Funktionen testen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Berta&#39;</span><span class="p">,</span> <span class="s1">&#39;Hans&#39;</span><span class="p">,</span> <span class="s1">&#39;Thomas&#39;</span><span class="p">]</span>
<span class="n">hashtable</span> <span class="o">=</span> <span class="n">new_hash_table</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hashtable</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>        <span class="c1"># False</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">contains</span><span class="p">(</span><span class="s1">&#39;Berta&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>         <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">search_index</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>    <span class="c1"># 11</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">search_index</span><span class="p">(</span><span class="s1">&#39;Berta&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>     <span class="c1"># 13</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>          <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>          <span class="c1"># False</span>

<span class="c1"># fill the list to test if everything works if it is full</span>
<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">unique_names_lex</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">]:</span>
    <span class="n">insert</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span>
    
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">hashtable</span> <span class="si">= }</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">all</span><span class="p">([</span><span class="n">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">)</span> <span class="o">==</span> <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)])</span>
</pre></div>
</div>
<p>Die letzte Zeile des Codes erzeugt eine Liste aus boolschen Werten und wertet diese durch <code class="docutils literal notranslate"><span class="pre">all</span></code> aus.
<code class="docutils literal notranslate"><span class="pre">all</span></code> ergibt genau dann <code class="docutils literal notranslate"><span class="pre">True</span></code> wenn jeder Wert in der Liste <code class="docutils literal notranslate"><span class="pre">True</span></code> ist.
Der Wert am Index <code class="docutils literal notranslate"><span class="pre">index</span></code> ist dabei <code class="docutils literal notranslate"><span class="pre">True</span></code> genau dann wenn der <code class="docutils literal notranslate"><span class="pre">search_index(name,</span> <span class="pre">hashtable)</span> <span class="pre">=</span> <span class="pre">index</span></code> wobei <code class="docutils literal notranslate"><span class="pre">name</span></code> am Index <code class="docutils literal notranslate"><span class="pre">index</span></code> der Liste <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> steht.</p>
<p>Was noch fehlt ist das Löschen eines Elements in unserer Hashtable.
Für das offene Hashing ist dies recht einfach: Wir suchen das Fach und löschen das Element aus diesem heraus.
Für das geschlossenes Hashing ist dies jedoch nicht so einfach!
Angenommen wir fürgen die Schlüssel <code class="docutils literal notranslate"><span class="pre">'Anna'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Alex'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Clara'</span></code>, <code class="docutils literal notranslate"><span class="pre">'Alba'</span></code> und <code class="docutils literal notranslate"><span class="pre">'Fabian'</span></code> nacheinander in eine leere Hashtabelle ein.
Und angenommen wir verwenden als Hashfunktion <code class="docutils literal notranslate"><span class="pre">index_of</span></code> und eine <em>lineare Sondierung</em>.
Dann erhalten wir als Resultat die Liste in <a class="reference internal" href="#fig-closed-hashing-deletion"><span class="std std-numref">Abbildung 5.8</span></a> aus.</p>
<div class="figure align-default" id="fig-closed-hashing-deletion">
<a class="reference internal image-reference" href="../../_images/closed-hashing-deletion.png"><img alt="../../_images/closed-hashing-deletion.png" src="../../_images/closed-hashing-deletion.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5.8 </span><span class="caption-text">Löschvorgang beim geschlossenes Hashing mit linearer Sondierung: Es wird der Schlüssel <code class="docutils literal notranslate"><span class="pre">'Alex'</span></code> gelöscht.</span><a class="headerlink" href="#fig-closed-hashing-deletion" title="Permalink to this image">¶</a></p>
</div>
<p>Wenn wir nun <code class="docutils literal notranslate"><span class="pre">'Alex'</span></code> einfach löschen und anschließend nach <code class="docutils literal notranslate"><span class="pre">'Alba'</span></code> suchen, werden wir beim Index <code class="docutils literal notranslate"><span class="pre">1</span></code> stoppen und diesen Namen nicht mehr finden!
Löschen wir <code class="docutils literal notranslate"><span class="pre">'Alex'</span></code> müssen wir alle Namen die einen größeren Index wie <code class="docutils literal notranslate"><span class="pre">'Alex'</span></code> haben und lückenlos aufeinander folgen, ebenfalls löschen und erneut einfügen.
Beachten Sie, dass sich die Position von <code class="docutils literal notranslate"><span class="pre">'Clare'</span></code> in der Liste in <a class="reference internal" href="#fig-closed-hashing-deletion"><span class="std std-numref">Abbildung 5.8</span></a> nicht verändert, da <code class="docutils literal notranslate"><span class="pre">index_of('Clare')</span> <span class="pre">==</span> <span class="pre">2</span></code>.</p>
<div class="exercise admonition" id="name-register-open-hashing-delete-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.24 </span>(Schlüssel löschen)</p>
<div class="section" id="exercise-content">
<p>Implementieren Sie den beschriebenen Algorithmus zum löschen eines Schlüssels in der Hashtabelle, d.h. implementieren Sie die Funktion <code class="docutils literal notranslate"><span class="pre">delete(name,</span> <span class="pre">hashtable)</span></code>.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span><span class="p">(</span><span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
            <span class="n">hashtable</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>Lassen Sie uns das Beispiel aus <a class="reference internal" href="#fig-closed-hashing-deletion"><span class="std std-numref">Abbildung 5.8</span></a> testen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Anna&#39;</span><span class="p">,</span> <span class="s1">&#39;Alex&#39;</span><span class="p">,</span> <span class="s1">&#39;Clara&#39;</span><span class="p">,</span> <span class="s1">&#39;Alba&#39;</span><span class="p">,</span> <span class="s1">&#39;Fabian&#39;</span><span class="p">]</span>
<span class="n">hashtable</span> <span class="o">=</span> <span class="n">new_hash_table</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">index_of</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
<span class="n">delete</span><span class="p">(</span><span class="s1">&#39;Alex&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">index_of</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
</pre></div>
</div>
<p>Nun wird es zeit unsere Hashtabelle mit den Babynamen aus <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> zu befüllen.</p>
<div class="exercise admonition" id="name-register-open-hashing-fill-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.25 </span>(Hashtable füllen)</p>
<div class="section" id="exercise-content">
<p>Füllen Sie nun eine neue <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> mit den Namen aus <code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code>.
Achten Sie auf die Zeit die dieser Vorgang in Anspruch nimmt.
Was fällt Ihnen auf?
Finden Sie eine Erklärung.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hashtable</span> <span class="o">=</span> <span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">)</span>
</pre></div>
</div>
<div class="solution dropdown admonition" id="name-register-open-hashing-fill-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#name-register-open-hashing-fill-exercise"><span>Exercise 5.25</span></a></p>
<div class="section" id="solution-content">
<p>Der Vorgang nimmt eine beachtliche Zeit in Anspruch.
<code class="docutils literal notranslate"><span class="pre">unique_names_lex</span></code> enthält 6782 Namen.
Unsere Hashfunktion liefert jedoch nur Werte zwischen 0 und 25.
Damit iterieren wir für das Einfügen des <span class="math notranslate nohighlight">\(m\)</span>-ten Elements über mindestens <span class="math notranslate nohighlight">\(m-25\)</span> Elemente.
Insgesamt benötigen wir damit in etwa</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=1}^n i = \frac{n \cdot (n+1)}{2}
\]</div>
<p>das sind</p>
<div class="math notranslate nohighlight">
\[
6782 \cdot 6783 / 2 \approx 23 \cdot 10^6
\]</div>
<p>also circa 23 Millionen Schritte! In anderen Worten wir haben immens viele Kollisionen d.h. unsere Hashfunktion <code class="docutils literal notranslate"><span class="pre">index_of</span></code> ist miserabel!</p>
</div>
</div>
</div>
<div class="section" id="hashfunktionen">
<h3><span class="section-number">5.3.2. </span>Hashfunktionen<a class="headerlink" href="#hashfunktionen" title="Permalink to this headline">¶</a></h3>
<p>Was genau ist eine Hashfunktion und wozu ist diese gut?</p>
<div class="admonition-hashfunktion admonition">
<p class="admonition-title">Hashfunktion</p>
<p>Eine Hashfunktion über einer Menge <span class="math notranslate nohighlight">\(E\)</span> (zum Beispiel die Menge aller Zeichenketten)</p>
<div class="math notranslate nohighlight">
\[h : \mathcal{U} \rightarrow \{0, \ldots, n\}\]</div>
<p>erzeugt durch meist einfache arithmetische Berechnungen aus einem Schlüssel <span class="math notranslate nohighlight">\(k \in \mathcal{K} \subseteq \mathcal{U}\)</span> eine natürliche Zahl, sodass</p>
<div class="math notranslate nohighlight" id="equation-name-register-hash-eq-1">
<span class="eqno">(5.5)<a class="headerlink" href="#equation-name-register-hash-eq-1" title="Permalink to this equation">¶</a></span>\[k_i = k_j \Rightarrow h(k_i) = h(k_j)\]</div>
<p>Den Wert <span class="math notranslate nohighlight">\(h(k)\)</span> nennen wir Hashwert von <span class="math notranslate nohighlight">\(k\)</span>.</p>
</div>
<p>Sind zwei Schlüssel verschieden muss die Hashfunktion hingegen keine verschiedenen Zahlen zurückliefern!
Die einfachste gültige und zugleich recht nutzlose Hashfunktion ist eine Konstante z.B. <span class="math notranslate nohighlight">\(h(k) = 0\)</span>.</p>
<p>Hashfunktionen werden oft verwendet um zu prüfen ob zwei Schlüssel gleich sind.
Aus Gleichung <a class="reference internal" href="#equation-name-register-hash-eq-1">(5.5)</a> folgt:</p>
<div class="math notranslate nohighlight" id="equation-name-register-hash-eq-2">
<span class="eqno">(5.6)<a class="headerlink" href="#equation-name-register-hash-eq-2" title="Permalink to this equation">¶</a></span>\[h(k_i) \neq h(k_j) \Rightarrow k_i \neq k_j.\]</div>
<p>Deshalb wertet man erst die Hashfunktion der beiden Schlüssel aus und erst wenn diese die gleichen Werte liefert, prüft man genauer weiter.
Da die Hashfunktion oft sehr schnell ausgewertet werden kann,
Insbesondere wenn</p>
<ol class="simple">
<li><p>die Ungleichheit wahrscheinlich ist und</p></li>
<li><p>wir eine <strong>gute Hashfunktion</strong> besitzten</p></li>
</ol>
<p>sind enorme Ersparnisse der Rechenzeit möglich.
Sie können zum Beispiel aus einem riesigen Textdokument einen Hashwert generieren und so zwei Textdokumente auf Gleichheit prüfen.</p>
<p>Was aber ist eine <strong>gute Hashfunktion</strong>?</p>
<p>Die erste wichtige Eigenschaft einer guten Hashfunktion <span class="math notranslate nohighlight">\(h\)</span> ist, dass diese gut <strong>streut</strong>.
D.h. Werten wir alle Hashwerte für unsere Schlüssel <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> aus, dann wäre es optimal wenn jeder Hashwert eindeutig ist, d.h. wenn</p>
<div class="math notranslate nohighlight">
\[
k_i \neq k_j \Rightarrow h(k_i) \neq h(k_j) 
\]</div>
<p>gilt.
Ist der Hashwert nahezu zufällig gleichverteilt zwischen <span class="math notranslate nohighlight">\(0\)</span> und <span class="math notranslate nohighlight">\(n-1\)</span> ist dies ebenfalls noch eine sehr gute Hashfunktion.
Leider ist das <em>Universum</em> <span class="math notranslate nohighlight">\(\mathcal{U}\)</span> meistens riesig, insbesondere deutlich größer als die Hashtabelle <span class="math notranslate nohighlight">\(\mathcal{L}\)</span>.
Kennen wir <span class="math notranslate nohighlight">\(\mathcal{K}\)</span> im Voraus und ändert sich diese Menge nicht, dann lässt sich oft eine perfekte Hashfunktion berechnen.
Ein Geburtsdatum oder der Fingerabdruck (in einer Zahl codiert) wären Hashwert einer Person aus dem echten Leben.
Das Geburtsdatum wäre jedoch ein schlechter Hashwert, da er für sehr viele Menschen gleich ist.
Der Fingerabdruck hingegen ist ein sehr guter Hashwert.</p>
<p>Die zweite wichtige Eigenschaft einer guten Hashfunktion <span class="math notranslate nohighlight">\(h\)</span> ist, dass ihre Auswertung <strong>billig</strong> ist.
Die Auswertung sollte in konstant vielen Schritten vonstatten gehen.
Nur wenn Sie billig ist, lohnt sich der Umweg über eine Hashfunktion.</p>
</div>
<div class="section" id="die-build-in-hashfunktion">
<h3><span class="section-number">5.3.3. </span>Die Build-in Hashfunktion<a class="headerlink" href="#die-build-in-hashfunktion" title="Permalink to this headline">¶</a></h3>
<p>Bevor wir unsere eigene verbesserte Hashfunktion schreiben, nutzten wir doch einmal was uns <code class="docutils literal notranslate"><span class="pre">Python</span></code> gegeben hat.</p>
<div class="exercise admonition" id="name-register-hashing-pythons-hash-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.26 </span>(Pythons Hashfunktion)</p>
<div class="section" id="exercise-content">
<ol>
<li><p>Lesen Sie die Dokumentation zur <code class="docutils literal notranslate"><span class="pre">Python</span></code>-Funktion <code class="docutils literal notranslate"><span class="pre">hash</span></code>. Sie finden diese <a class="reference external" href="https://docs.python.org/3/library/functions.html?highlight=hash#hash">hier</a>.</p></li>
<li><p>Verwenden Sie die <code class="docutils literal notranslate"><span class="pre">hash</span></code> als Ihre Hashfunktion. Bauen Sie dafür die Funktionen aus der vorherigen Aufgabe so um, dass sie diesen eine Hashfunktion <code class="docutils literal notranslate"><span class="pre">hash_func</span></code> als Argument übergeben können.</p></li>
<li><p>Führen Sie anschließend</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hashtable</span> <span class="o">=</span> <span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">)</span>
</pre></div>
</div>
<p>aus und beobachten Sie wie lange die Funktion arbeitet.</p>
</li>
</ol>
</div>
</div>
<p>Die Berechnungszeit ist deutlich kürzer.
Lassen Sie uns erneut testen ob alles mit rechten Dingen zugeht.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hashtable</span> <span class="o">=</span> <span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">)</span>
<span class="nb">all</span><span class="p">([</span><span class="n">search_index</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">)</span> <span class="o">==</span> <span class="n">index</span> 
     <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span> 
     <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">])</span>
</pre></div>
</div>
<div class="exercise admonition" id="name-register-hashing-countcollisions-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.27 </span>(Kollisionen zählen)</p>
<div class="section" id="exercise-content">
<p>Schreiben Sie eine <code class="docutils literal notranslate"><span class="pre">Python</span></code>-Funktion <code class="docutils literal notranslate"><span class="pre">collisions(hashtable,</span> <span class="pre">hash_func)</span></code>, welche Ihnen für die Liste Elemente der Liste <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> die Kollisionen abhängig von der Hashfunktion <code class="docutils literal notranslate"><span class="pre">hash_func</span></code> zählt.
In anderen Worten <code class="docutils literal notranslate"><span class="pre">collisions(hashtable,</span> <span class="pre">hash_func)</span></code> berechnet die Anzahl die Kollisionen die stattgefunden haben um die Elemente in <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> einzufügen.</p>
<p>Vergleiche Sie die Hashfunktionen <code class="docutils literal notranslate"><span class="pre">index_of</span></code> und <code class="docutils literal notranslate"><span class="pre">hash</span></code>.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">collisions</span><span class="p">(</span><span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">collisions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hashtable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">hashtable</span><span class="p">)</span>
            <span class="n">collisions</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">collisions</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">collisions</span><span class="p">(</span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="nb">hash</span><span class="p">),</span> <span class="nb">hash</span><span class="p">))</span>         <span class="c1"># 3610</span>
<span class="nb">print</span><span class="p">(</span><span class="n">collisions</span><span class="p">(</span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">index_of</span><span class="p">),</span> <span class="n">index_of</span><span class="p">))</span> <span class="c1"># 60751108</span>
</pre></div>
</div>
<p>3610 <strong>Kollisionen</strong> für das Einfügen von 6782 ist ein sehr guter Schnitt.
Das ist weniger als eine Kollision pro Element!
<code class="docutils literal notranslate"><span class="pre">index_of</span></code> verursacht hingegen über 60 Millionen <strong>Kollisionen</strong>!</p>
<p>Im Abschnitt <a class="reference internal" href="../08/5-python.html#sec-python"><span class="std std-ref">Python</span></a> hatten wir erwähnt, dass <code class="docutils literal notranslate"><span class="pre">Python</span></code> aufwendige Berechnungen in <code class="docutils literal notranslate"><span class="pre">C/C++</span></code>-Coder verlagert.
Dies ist auch für die Funktion <code class="docutils literal notranslate"><span class="pre">hash</span></code> der Fall.
Im folgenden zeigen wir ihnen den Code der Hashfunktion <code class="docutils literal notranslate"><span class="pre">hash</span></code> für Zeichenketten.
Bitte erschrecken Sie nicht.
Sie brauchen den Code nicht verstehen!
Die Berechnung von Hashwerten sieht oft nach viel Voodoo aus.
Hier werden Zahlen mit sogenannten <a class="reference internal" href="../06/2-representation.html#def-bit"><span class="std std-ref">Bit</span></a>-Verschiebungen manipuliert.
Man sieht dem Code an, dass er auf Performance und nicht auf Lesbarkeit getrimmt ist.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">long</span>
<span class="n">string_hash</span><span class="p">(</span><span class="n">PyStringObject</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">Py_ssize_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="k">register</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>

<span class="cp">#ifdef Py_DEBUG</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">_Py_HashSecret_Initialized</span><span class="p">);</span>
<span class="cp">#endif</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_shash</span> <span class="o">!=</span> <span class="mi">-1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_shash</span><span class="p">;</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="cm">/*</span>
<span class="cm">      We make the hash of the empty string be 0, rather than using</span>
<span class="cm">      (prefix ^ suffix), since this slightly obfuscates the hash secret</span>
<span class="cm">    */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_shash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_sval</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">_Py_HashSecret</span><span class="p">.</span><span class="n">prefix</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="mi">7</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1000003</span><span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="o">^</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">Py_SIZE</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">x</span> <span class="o">^=</span> <span class="n">_Py_HashSecret</span><span class="p">.</span><span class="n">suffix</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">-2</span><span class="p">;</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">ob_shash</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eine-eigene-gute-hashfunktion">
<h3><span class="section-number">5.3.4. </span>Eine eigene gute Hashfunktion<a class="headerlink" href="#eine-eigene-gute-hashfunktion" title="Permalink to this headline">¶</a></h3>
<p>Lassen Sie uns nun unsere eigene verbesserte Hashfunktion entwickeln.
Wir suchen nach einer Funktion, welche verschiedene Zeichenketten in verschiedene natürliche Zahlen umwandelt.
Verwenden wir nur ein Zeichen für die Berechnung ist klar, dass wir nicht mehr als 25 verschiedene Zahlen erwarten können.</p>
<p>Lassen Sie uns deshalb mehrere Zeichen für die Berechnung des Hashwerts verwenden.
Eine erste Idee wäre die Summe der codierten Zeichen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_func_sum</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">+=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="nb">print</span><span class="p">(</span><span class="n">collisions</span><span class="p">(</span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">hash_func_sum</span><span class="p">),</span> <span class="n">hash_func_sum</span><span class="p">))</span>
</pre></div>
</div>
<p>Immerhin erreichen wir damit nur noch 20 Millionen <strong>Kollisionen</strong>, was jedoch immernoch viel zu viel ist.
Wie sieht es mit der Multiplikation aus?</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_func_mul</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">*=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="nb">print</span><span class="p">(</span><span class="n">collisions</span><span class="p">(</span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">hash_func_mul</span><span class="p">),</span> <span class="n">hash_func_mul</span><span class="p">))</span>
</pre></div>
</div>
<p>Etwas schlechter fällt hierfür das Ergebnis aus.</p>
<div class="exercise admonition" id="hash-add-mul-hashmap-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.28 </span>(Hashfunktion der Addition und Multiplikation)</p>
<div class="section" id="exercise-content">
<p>Warum ist die beiden Hashfunktion <code class="docutils literal notranslate"><span class="pre">hash_func_sum</span></code> und <code class="docutils literal notranslate"><span class="pre">hash_func_mul</span></code>, keine besonders guten Hashfunktionen?</p>
</div>
</div>
<div class="solution dropdown admonition" id="hash-add-mul-hashmap-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#hash-add-mul-hashmap-exercise"><span>Exercise 5.28</span></a></p>
<div class="section" id="solution-content">
<p>Sowohl die Addition als auch die Multiplikation ist kommutativ deswegen fließt die Reihenfolge der Zeichen nicht in die Berechnung ein.
<code class="docutils literal notranslate"><span class="pre">Thomas</span></code> und <code class="docutils literal notranslate"><span class="pre">hasToh</span></code> haben den gleichen Hashwert.</p>
</div>
</div>
<p>Erinnern wir uns zurück an die Darstellung von Zahlen im Binär und Dezimalsystem, siehe <a class="reference internal" href="../06/2-representation.html#sec-binary-numbers"><span class="std std-ref">Zahlen im Binärsystem</span></a>.
Auch hier haben wir aus einer Folge von Zeichen <code class="docutils literal notranslate"><span class="pre">0</span></code> und <code class="docutils literal notranslate"><span class="pre">1</span></code> eine <strong>eindeutige Zahl</strong> berechnet.
Aus einer Zahl <span class="math notranslate nohighlight">\(b_{n-1} \ldots b_2b_1b_0\)</span> in Binärdarstellung haben wir die eindeutige Dezimalzahl</p>
<div class="math notranslate nohighlight">
\[
\sum\limits_{i=0}^n b_i \cdot 2^{i} = b_0 \cdot 2^0 + b_1 \cdot 2^1 + \cdots b_{n-1} \cdot 2^{n-1}
\]</div>
<p>berechnet. Dieses <strong>Berechnungsmuster</strong> können wir wiederverwenden!
Angenommen unsere Zeichenkette als Folge von Zahlen (ASCII) ist <span class="math notranslate nohighlight">\(s_{n-1} \ldots s_2s_1s_0\)</span> und <span class="math notranslate nohighlight">\(p\)</span> ist irgendeine <em>Basis</em>, dann ist</p>
<div class="math notranslate nohighlight">
\[
\sum\limits_{i=0}^n s_i \cdot p^{i} = s_0 \cdot p^0 + s_1 \cdot p^1 + \cdots s_{n-1} \cdot p^{n-1}
\]</div>
<p>eine eindeutige Dezimalzahl sofern <span class="math notranslate nohighlight">\(p\)</span> eine valide Basis ist.</p>
<p>Wie im Binärsystem als auch im Dezimalsystem muss <span class="math notranslate nohighlight">\(p\)</span> größer sein als alle Ziffern des Zahlensystems.
In unserem Fall müsste <span class="math notranslate nohighlight">\(p\)</span> größer sein als <code class="docutils literal notranslate"><span class="pre">ord(&quot;z&quot;)</span></code>.
Da wir jedoch keine unbedingte Eindeutigkeit benötigen ist ein kleineres <span class="math notranslate nohighlight">\(p\)</span> auch gültig.</p>
<p>Unsere Hashfunktion ist durch</p>
<div class="math notranslate nohighlight" id="equation-name-register-good-hash-function-1">
<span class="eqno">(5.7)<a class="headerlink" href="#equation-name-register-good-hash-function-1" title="Permalink to this equation">¶</a></span>\[h(s_{n-1} \ldots s_2s_1s_0) = \sum\limits_{i=0}^n s_i \cdot p^{i} = s_0 \cdot p^0 + s_1 \cdot p^1 + \cdots s_{n-1} \cdot p^{n-1}\]</div>
<p>gegeben.</p>
<div class="exercise admonition" id="prime-hashmap-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.29 </span>(Eindeutigkeit)</p>
<div class="section" id="exercise-content">
<p>Was für ein kleines <span class="math notranslate nohighlight">\(p\)</span> könnte sich besonders gut eignen und warum?</p>
</div>
</div>
<div class="solution dropdown admonition" id="prime-hashmap-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#prime-hashmap-exercise"><span>Exercise 5.29</span></a></p>
<div class="section" id="solution-content">
<p>Eine Primzahl <span class="math notranslate nohighlight">\(p\)</span> eignet sich besonders gut, da dann die Produkte</p>
<div class="math notranslate nohighlight">
\[
s_i \cdot p^{n-1-i} \text{ und } s_j \cdot p^{n-1-j}
\]</div>
<p>nur gleich sein können, wenn <span class="math notranslate nohighlight">\(p\)</span> in der Faktorisierung von <span class="math notranslate nohighlight">\(s_i\)</span> oder <span class="math notranslate nohighlight">\(s_j\)</span> vorkommt.
Ist <span class="math notranslate nohighlight">\(p\)</span> keine Primzahl gibt es mehr Möglichkeiten, dass die beiden Produkte gleich sind.</p>
</div>
</div>
<p>Sie sehen wir tauchen ein wenig in die Zahlentheorie ein.
Dieses mathematische Denken ist auch ein Teil des <a class="reference internal" href="../02/what-is-ct.html#sec-what-is-ct"><span class="std std-ref">Computational Thinkings</span></a>!</p>
<div class="exercise admonition" id="good-hashfunction-hashmap-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.30 </span>(Eine gute Hashfunktion)</p>
<div class="section" id="exercise-content">
<ol class="simple">
<li><p>Implementieren Sie die Hashfunktion welche durch Gleichung <a class="reference internal" href="#equation-name-register-good-hash-function-1">(5.7)</a> definiert ist. <code class="docutils literal notranslate"><span class="pre">83</span></code> eignet sich als Primzahl (nicht zu klein und groß genug).</p></li>
<li><p>Testen Sie Ihre neue Hashfunktion durch <code class="docutils literal notranslate"><span class="pre">collisions</span></code>.</p></li>
</ol>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">prime</span> <span class="o">=</span> <span class="mi">83</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
        <span class="n">hash_value</span> <span class="o">*=</span> <span class="n">prime</span>
        <span class="n">hash_value</span> <span class="o">+=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hash_value</span>

<span class="nb">print</span><span class="p">(</span><span class="n">collisions</span><span class="p">(</span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">),</span> <span class="n">hash_func</span><span class="p">))</span> <span class="c1"># 3432</span>
</pre></div>
</div>
<p>Wir haben es geschafft!!!
Nur noch 3432 Kollisionen!
Damit sind wir für unseren Fall besser als die <code class="docutils literal notranslate"><span class="pre">Python</span></code>-Funktion <code class="docutils literal notranslate"><span class="pre">hash</span></code>.
Die Berechnungszeit hängt noch von der Anzahl der Zeichen eines Namen <code class="docutils literal notranslate"><span class="pre">name</span></code> ab.
Wir könnten uns darauf einigen nur die ersten <span class="math notranslate nohighlight">\(m\)</span> Zeichen zu berücksichtige.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">hash_func</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">prime</span> <span class="o">=</span> <span class="mi">83</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">))):</span>
        <span class="n">hash_value</span> <span class="o">*=</span> <span class="n">prime</span>
        <span class="n">hash_value</span> <span class="o">+=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">hash_value</span>
<span class="nb">print</span><span class="p">(</span><span class="n">collisions</span><span class="p">(</span><span class="n">new_hash_table</span><span class="p">(</span><span class="n">unique_names_lex</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">),</span> <span class="n">hash_func</span><span class="p">))</span>
</pre></div>
</div>
<p>Das Ergebnis ist mit 3692 Kollisionen immernoch sehr gut und die Auswertung benötigt nun eine konstante Anzahl von maximal 8 Schritten.</p>
</div>
<div class="section" id="unser-dictionary">
<h3><span class="section-number">5.3.5. </span>Unser Dictionary<a class="headerlink" href="#unser-dictionary" title="Permalink to this headline">¶</a></h3>
<p>Bislang können wir in unsere Hashtable Namen einfügen, löschen und suchen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
<span class="n">search</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
<span class="n">delete</span><span class="p">(</span><span class="s1">&#39;Dieter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
</pre></div>
</div>
<p>Die Funktionalität eines <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> haben wir damit noch nicht erreicht.
Das besondere des <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a> ist, dass es einen Schlüssel <code class="docutils literal notranslate"><span class="pre">key</span></code> und einen Wert <code class="docutils literal notranslate"><span class="pre">value</span></code> gibt und dass wir den Wert mit dem Schlüssel identifizieren können:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dictionary</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Dieter&#39;</span><span class="p">:</span> <span class="s1">&#39;1977-05-06&#39;</span><span class="p">,</span> <span class="s1">&#39;Bella&#39;</span><span class="p">:</span> <span class="s1">&#39;1999-10-11&#39;</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;Dieter&#39;</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;Bella&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Das ist genau dann sehr nützlich, wenn wir den Schlüssel einfach berechnen und auch hashen können den Wert jedoch nicht.
In unserer Hashtable sind Namen die Schlüssel, was bisher fehlt ist der Wert.
Um unsere Hashtable um Werte zu erweitern machen wir aus der Liste <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> wir zwei gleich Lange Listen <code class="docutils literal notranslate"><span class="pre">keys</span></code> und <code class="docutils literal notranslate"><span class="pre">values</span></code>.
Dafür müssen wir selbstverständlich alle bisher implementierten Funktionen anpassen.</p>
<div class="exercise admonition" id="our-dictionary-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.31 </span>(Unser Dictionary)</p>
<div class="section" id="exercise-content">
<p>Machen Sie aus der <code class="docutils literal notranslate"><span class="pre">hashtable</span></code> zwei Listen <code class="docutils literal notranslate"><span class="pre">keys</span></code> und <code class="docutils literal notranslate"><span class="pre">values</span></code>, sodass sich in <code class="docutils literal notranslate"><span class="pre">keys</span></code> die Schlüssel unseres Dictionary befinden und in <code class="docutils literal notranslate"><span class="pre">values</span></code> die Werte.
Passen Sie alle Funktionen entsprechend an. Sie müssen folgenden Funktionen anpassen:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">search_index</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">contains</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_value</span></code>: Dies Funktion sollte nicht mehr den Schlüssel sondern den Wert zurückliefern!</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">insert</span></code>: Sollte nur einen neuen Wert einfügen falls es den Schlüssel dafür noch nicht gibt.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">delete</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">new_hash_table</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">collisions</span></code></p></li>
</ul>
<p>Führen Sie zusätzlich eine Funktion <code class="docutils literal notranslate"><span class="pre">set_value</span></code>, welche den Wert eines Schlüssels ändert, sofern dieser existiert.</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">search_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">j</span>
        
    <span class="c1"># there is no free place left</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span>

<span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kc">None</span>

<span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    
    <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
      
    <span class="k">if</span> <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        
        <span class="k">return</span> <span class="kc">True</span>

<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">search_index</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
        <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span><span class="p">(</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">next_key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
            <span class="n">next_value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
            <span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">next_key</span><span class="p">,</span> <span class="n">next_value</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">new_hash_table</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
        <span class="n">hash_keys</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)]</span>
        <span class="n">hash_values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)]</span>
        <span class="n">hashtable</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_keys</span><span class="p">,</span> <span class="n">hash_values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hashtable</span>
    <span class="k">return</span> <span class="p">([],[])</span>

<span class="k">def</span> <span class="nf">collisions</span><span class="p">(</span><span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="o">=</span><span class="nb">hash</span><span class="p">):</span>
    <span class="n">keys</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="n">hashtable</span>
    <span class="n">collisions</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">hash_func</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
            <span class="n">collisions</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">index</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">collisions</span>
</pre></div>
</div>
<p>Tests:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span>
<span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Berta&#39;</span><span class="p">,</span> <span class="s1">&#39;Hans&#39;</span><span class="p">,</span> <span class="s1">&#39;Thomas&#39;</span><span class="p">]</span>
<span class="n">hashtable</span> <span class="o">=</span> <span class="n">new_hash_table</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">))</span>         <span class="c1"># Hans</span>
<span class="n">set_value</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;Peter&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">))</span>         <span class="c1"># Peter</span>
<span class="nb">print</span><span class="p">(</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;Anna&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">))</span>    <span class="c1"># False</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">))</span>         <span class="c1"># Thomas</span>
<span class="nb">print</span><span class="p">(</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;Anna&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">))</span>    <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="n">hashtable</span><span class="p">,</span> <span class="n">hash_func</span><span class="p">))</span>         <span class="c1"># Anna</span>
</pre></div>
</div>
<p>Unsere Funktionen und das Paar <code class="docutils literal notranslate"><span class="pre">keys</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code> bilden unser eigenes <a class="reference internal" href="dive-bell.html#def-python-dictionary"><span class="std std-ref">Dictionary</span></a>.</p>
</div>
<div class="section" id="hashtable-klasse-optional">
<h3><span class="section-number">5.3.6. </span>Hashtable Klasse (optional)<a class="headerlink" href="#hashtable-klasse-optional" title="Permalink to this headline">¶</a></h3>
<p>Um die Funktionalität besser zu Kapseln und nicht eignet sich eine Klasse <code class="docutils literal notranslate"><span class="pre">Hashtable</span></code>.
Wir haben Ihnen diese aus den Funktionen obigen und den zwei Listen gebaut.
Anstatt <code class="docutils literal notranslate"><span class="pre">new_hash_table</span></code> haben wir durch <code class="docutils literal notranslate"><span class="pre">insert_all</span></code> ersetzt.</p>
<p>Zudem gibt es noch drei weitere Funktionen <code class="docutils literal notranslate"><span class="pre">size</span></code>, <code class="docutils literal notranslate"><span class="pre">__has_to_resize</span></code> und <code class="docutils literal notranslate"><span class="pre">__resize</span></code>.
<code class="docutils literal notranslate"><span class="pre">size</span></code> liefert die Anzahl der Elemente in der Hashtable zurück.
<code class="docutils literal notranslate"><span class="pre">__has_to_resize</span></code> ist genau dann wahr wenn die Hashtable vergrößert oder verkleinert werden muss und <code class="docutils literal notranslate"><span class="pre">__resize</span></code> führt diese Anpassung durch.</p>
<p>Wann immer ein Element aus der Hashtable gelöscht oder eingefügt wird, testen wir mit <code class="docutils literal notranslate"><span class="pre">__has_to_resize</span></code> ob wir die Hashtable anpassen müssen.
Ist die Hahstable <span class="math notranslate nohighlight">\(2/3\)</span> voll, dann wird sie vergrößert und ist sie nur <span class="math notranslate nohighlight">\(1/6\)</span> befüllt, wird sie verkleinert.
Wann immer die Größe der Hahstable angepasst wird, wird diese auf <span class="math notranslate nohighlight">\(1/4\)</span> befüllt gesetzt.
Alle Elemente werden neu eingefügt.</p>
<div class="exercise admonition" id="our-dictionary-size-exercise">
<p class="admonition-title"><span class="caption-number">Exercise 5.32 </span>(Größe der Hashtable)</p>
<div class="section" id="exercise-content">
<p>Weshalb sollte die Hashtable nicht zu groß und nicht zu klein sein?</p>
</div>
</div>
<div class="solution dropdown admonition" id="our-dictionary-size-solution">
<p class="admonition-title">Solution to <a class="reference external" href="#our-dictionary-size-exercise"><span>Exercise 5.32</span></a></p>
<div class="section" id="solution-content">
<p>Ist die Hashtable zu groß verbrauchen wir unnötig viel Speicher.
Ist sie hingegen zu klein gibt es mehr und mehr <strong>Kollisionen</strong> und die Laufzeit der Funktionen der Hashtable erhöht sich!</p>
</div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Hashtable</span><span class="p">():</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hashf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hashf</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hashf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span> <span class="o">=</span> <span class="n">hashf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_size</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__search_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">j</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">j</span>

        <span class="c1"># there is no free place left</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">set_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__has_to_resize</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__resize</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

    <span class="k">def</span> <span class="nf">__has_to_resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">6</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">6</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__resize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="mi">4</span>  <span class="c1"># 1 / 4 filled</span>
        <span class="n">old_keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span>
        <span class="n">old_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_keys</span><span class="p">,</span> <span class="n">old_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__search_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">while</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">next_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
                <span class="n">next_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">next_key</span><span class="p">,</span> <span class="n">next_value</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__has_to_resize</span><span class="p">()):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__resize</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">insert_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="n">hash_keys</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)]</span>
            <span class="n">hash_values</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)]</span>
            <span class="n">hashtable</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash_keys</span><span class="p">,</span> <span class="n">hash_values</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">hashtable</span>
        <span class="k">return</span> <span class="p">([],</span> <span class="p">[])</span>

    <span class="k">def</span> <span class="nf">collisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">collisions</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_func</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span>
                <span class="n">collisions</span> <span class="o">+=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collisions</span>

    <span class="k">def</span> <span class="nf">hashf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="n">hash_value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">prime</span> <span class="o">=</span> <span class="mi">83</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">))):</span>
            <span class="n">hash_value</span> <span class="o">*=</span> <span class="n">prime</span>
            <span class="n">hash_value</span> <span class="o">+=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">hash_value</span>
</pre></div>
</div>
<p>Folgender Code zeigt die Verwendung der neuen Klasse</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">simple_test</span><span class="p">():</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">]</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Berta&#39;</span><span class="p">,</span> <span class="s1">&#39;Hans&#39;</span><span class="p">,</span> <span class="s1">&#39;Thomas&#39;</span><span class="p">]</span>

    <span class="n">hashtable</span> <span class="o">=</span> <span class="n">Hashtable</span><span class="p">()</span>
    <span class="n">hashtable</span><span class="o">.</span><span class="n">insert_all</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
    <span class="n">hashtable</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">,</span> <span class="s1">&#39;Peter&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">,</span> <span class="s1">&#39;Anna&#39;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="s1">&#39;Anna&#39;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">hashtable</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">insert_and_delete_test</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="c1"># intentionally bad hash function!</span>
    <span class="n">hashtable</span> <span class="o">=</span> <span class="n">Hashtable</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">hashtable</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">hashtable</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="nb">all</span><span class="p">([</span><span class="n">hashtable</span><span class="o">.</span><span class="n">get_value</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">==</span>
          <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]))</span>

<span class="n">simple_test</span><span class="p">()</span>
<span class="n">insert_and_delete_test</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "BZoennchen/ct-book",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapters/11"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
        <div class='prev-next-bottom'>
            
    <a class='left-prev' id="prev-link" href="memory.html" title="previous page"><span class="section-number">4. </span>Speicher - alles ist eine Liste</a>
    <a class='right-next' id="next-link" href="../misc/bibliography.html" title="next page">Bibliography</a>

        </div>
        
        </div>
    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Benedikt Zönnchen, Sarah Ottinger, Martin Hobelsberger<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>